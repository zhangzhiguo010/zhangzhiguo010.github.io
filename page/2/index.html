<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>张治国的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="张治国的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="张治国的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张治国的博客">
  
    <link rel="alternate" href="/atom.xml" title="张治国的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张治国的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS-null和undefined" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-null和undefined/" class="article-date">
  <time datetime="2018-11-22T13:43:04.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-null和undefined/">JS-null和undefined</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：《JS高程》page24页、《JS权威指南》page44页</p>
<p>#一、null<br>代表“空值”，可以表示数字、字符串和对象是无值的。</p>
<p>#二、undefined<br>代表“未定义”，声明了变量但没赋值，那么这个变量的值就是undefined。</p>
<p>#三、null和undefined不同点</p>
<ul>
<li>有一个对象object  定义了但是暂时不想给值，就null，<br>  例子：var obj = nul;</li>
<li>有一个非对象  定义了但是暂时不想给值，就undefined，<br>  例子：var aa = undefined;</li>
</ul>
<p>#四、null和undefined的相同点：</p>
<ul>
<li>都表示值得空缺，可以互换使用；</li>
<li>null==undefined，null===undefined；</li>
<li>转成布尔值时都为false；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-null和undefined/" data-id="cjowb1ymk000eusqrwl3zfb5t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-Promist对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-Promist对象/" class="article-date">
  <time datetime="2018-11-22T13:23:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-Promist对象/">JS-Promist对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN文档</p>
<p>#一、创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我常用的创建方式*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">     	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject </span>)=&gt;</span>&#123;</span><br><span class="line">         	做事（异步任务）</span><br><span class="line">     		如果成功就调用 resolve（）</span><br><span class="line">       	如果失败就调用 reject（）</span><br><span class="line">      	&#125;)</span><br><span class="line">  	&#125;</span><br><span class="line">  myPromise().then(fn1, fn2).then(fn3, fn4)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果成功就调用resolve，也就是执行fn1，fn1的参数就是resolve的参数</p>
<ul>
<li>fn1执行成功则fn3被调用，fn3的参数就是fn1的return结果；</li>
<li>fn1执行出错则fn4被调用，fn4的参数就是fn1的return结果；</li>
</ul>
</li>
<li><p>如果失败就调用reject，也就是执行fn2，参数问题同上</p>
<ul>
<li>fn2执行成功则fn3被调用，参数问题同上；</li>
<li>fn2执行出错则fn4被调用，参数问题同上；</li>
</ul>
</li>
</ul>
<p>#二、 属性：</p>
<ul>
<li>Promise.length: 属性值总是1，表示构造函数的参数个数</li>
<li>Promise.prototype：表示Promise构造函数的原型，原型的constructor属性是Promise构造函数</li>
</ul>
<p>#三、方法：</p>
<p>###1. Promise.prototype.catch()</p>
<ul>
<li>如果成功，就不执行函数参数；</li>
<li>如果失败，就执行函数参数。</li>
</ul>
<p>###2. Promise.prototype.finally()</p>
<ul>
<li>无论成功还是失败，都执行函数参数，函数参数不接收参数。</li>
</ul>
<p>###3. Promise.prototype.then(）</p>
<ul>
<li>如果成功，就执行then的第一个函数参数；</li>
<li>如果失败，就执行then的第二个函数参数。</li>
</ul>
<p>###4. Promise.all()</p>
<ul>
<li>输入：数组</li>
<li>输出：Promise实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pro = <span class="built_in">Promise</span>.all([xx, yy, zz]); </span><br><span class="line">pro.then(AA, BB)</span><br></pre></td></tr></table></figure>
<ul>
<li>执行AA：迭代器中所有promise调用resolve时</li>
<li>执行BB：迭代器中至少一个promise调用reject时</li>
</ul>
<p>###5. Promise.race()</p>
<ul>
<li>输入：数组</li>
<li>输出：Promise实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xx = <span class="keyword">new</span> <span class="built_in">Promise</span>()    </span><br><span class="line"><span class="keyword">let</span> yy = <span class="keyword">new</span> <span class="built_in">Promise</span>()    </span><br><span class="line"><span class="keyword">let</span> zz = <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line"><span class="keyword">let</span> pro = <span class="built_in">Promise</span>.rece([xx, yy, zz])</span><br><span class="line">pro.then(AA, BB)</span><br></pre></td></tr></table></figure>
<ul>
<li>执行AA：迭代器中某个（最早的）promise调用resolve时。</li>
<li>执行BB：迭代器中某个（最早的）promise调用reject时。</li>
</ul>
<p>###6. Promise.reject()</p>
<ul>
<li>输入：失败原因</li>
<li>输出：Promise对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'失败的原因'</span>).then(</span><br><span class="line">	()=&gt;&#123; 从不会被调用 &#125;, </span><br><span class="line">	(ev)=&gt;&#123; 会被调用 &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>###7. Promise.resolve()</p>
<ul>
<li>输入：成功原因/数据</li>
<li>输出：Promise对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'成功原因/数据'</span>).then( </span><br><span class="line">	(ev)=&gt;&#123; 会被调用 &#125;, </span><br><span class="line">	()=&gt;&#123; 从不会被调用 &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-Promist对象/" data-id="cjowb1ymu000ousqrm7e23zi7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-JSON对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-JSON对象/" class="article-date">
  <time datetime="2018-11-22T13:05:27.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-JSON对象/">JS-JSON对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-JSON对象/" data-id="cjowb1yml000fusqrhdc6eo28" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-数组（基础）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-数组（基础）/" class="article-date">
  <time datetime="2018-11-22T12:43:34.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-数组（基础）/">JS-数组（基础）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN、《JS高程》、《JS权威指南》</p>
<p>#一、数组的创建和调用</p>
<p>##1.数组定义相关问题：</p>
<ul>
<li>数组是按次序排列的一组值，每个值的位置都有编号（从0开始），整个数组用方括号表示；</li>
<li>数组是特殊的对象，特殊在于他的键名/属性名是按次序排列的一组整数，</li>
<li>typeof运算符检测数组，返回object；</li>
<li>数组的原型链上有Array.prototype对象，该对象拥有操控数组的方法和属性；</li>
</ul>
<p>##2. 数组创建相关问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*new Array()*/</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="keyword">new</span> <span class="built_in">Array</span>( <span class="string">"red"</span>, <span class="string">"yellow"</span>, <span class="string">"blue"</span>);</span><br><span class="line"><span class="comment">/*数组直接量*/</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="string">"red"</span>, <span class="string">"yellow"</span>, <span class="string">"blue"</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>new Array( )方法中：<br>  只有一个参数是就是数组的长度，数组元素都是空元素；<br>  两个及以上参数时，才是数组！</li>
<li>new Array( )方法中，有没有new都一样，和对象与函数的一样，<br>  但是基本类型的构造函数创建方法有和没有new有着本质的区别。</li>
</ul>
<p>##3. 数组元素相关问题：</p>
<ul>
<li>和对象一样，数组的属性名也是字符串，写成数字，会转成字符串，arr[0]===arr[‘0’]；</li>
<li>数组的属性名不符合标识符规范，只能使用方括号操作数组，不能使用点运算符；</li>
<li>方括号法操作数组包括取元素，修改元素，新增元素</li>
<li>除了可以定义时赋值，也可以先定义后赋值，任何类型的数据都可以放入数组；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'22'</span>,<span class="number">33</span>, &#123;<span class="attr">a</span>:<span class="number">44</span>,<span class="attr">b</span>:<span class="string">'cc'</span>&#125;, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>#二、其他零散知识</p>
<p>###1. 数组空位：</p>
<ul>
<li>两个逗号之间没有任何值，则是空位，  </li>
<li>delete删除元素会创建空位，空位也占元素个数；</li>
<li>空位是可以读取的，返回undefined；</li>
<li>空位表示数组没有这个元素，所以不会被for/in等方法遍历到，</li>
<li>undefined表示数组有这个元素，值为undefined；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'abc'</span>, , <span class="literal">undefined</span>, <span class="string">'def'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*for/in循环会跳过空位*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123; <span class="built_in">console</span>.log(arr[i]) &#125;;    	<span class="comment">//'abc' undefined 'def'   </span></span><br><span class="line"></span><br><span class="line">arr.length; 					<span class="comment">//4  			length属性不会跳过空位</span></span><br><span class="line">arr[<span class="number">0</span>]; 						<span class="comment">//'abc'</span></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>];  </span><br><span class="line">arr[<span class="number">0</span>];   						<span class="comment">//undefined  	删除元素形成空位       </span></span><br><span class="line">arr.length;                    	<span class="comment">//4    			删除了元素但不影响元素个数</span></span><br><span class="line">arr[<span class="number">1</span>]; 						<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>###2. in运算符：</p>
<ul>
<li>in运算符检查数组是否有某个键名，它适用于对象也适用于数组；</li>
<li>如果某个位置是空位，in运算符返回false；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'位置0'</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> arr; 			<span class="comment">//非空位，返回true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr; 			<span class="comment">//undefined和空位不一样，返回true</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr; 			<span class="comment">//空位，返回fals</span></span><br></pre></td></tr></table></figure>
<p>###3. 类/伪数组对象：</p>
<ul>
<li>伪数组原型链上没有Array.prototype对象</li>
<li>如果一个对象的所有键名都是正整数或零，并且有length属性，它就是伪数组。</li>
<li>类数组对象不是数组，数组特有的方法，它是没有的，比如push等方法；</li>
<li>类数组对象虽然也有length属性，但它是固定的而数组的length是随着元素变化而变化的；</li>
<li>典型的类数组对象有字符串，函数的arguments对象，以及大多数的DOM元素集，<br>  如document.genElementsByTagName(‘p’);     </li>
<li>将类数组对象转成数组对象的方法有：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法1：推荐*/</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line"><span class="comment">/*方法2：slice方法*/</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-数组（基础）/" data-id="cjowb1ymt000nusqr69sfv7w7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-数组（升级）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-数组（升级）/" class="article-date">
  <time datetime="2018-11-22T10:15:18.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-数组（升级）/">JS-数组（升级）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN、Underscore.js库</p>
<p>#一、数组的属性：</p>
<p>###1. Array.prototype<br>    表示Array构造函数的原型（对象）</p>
<p>###2. Array.prototype.constructor<br>    表示创建实例数组的那个构造函数的引用（此处是引用是地址，不是简单的字符串格式的函数名）</p>
<p>###3. Array.length<br>    返回数组元素个数，它是一个动态值，等于键名中最大整数加上1，故数组是一个动态的数据结构；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];  </span><br><span class="line"><span class="comment">/*输出2*/</span></span><br><span class="line">  	arr.length;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">/*undefined: 当length大于实际个数，则元素会新增，新增的都是undefined；*/</span></span><br><span class="line">  	arr.length=<span class="number">3</span>; arr[<span class="number">3</span>];</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">/*undefined: 当length小于实际个数，则元素会删除，删除后面的不在length以内的元素；*/</span></span><br><span class="line">  	arr.length=<span class="number">1</span>; arr[<span class="number">1</span>]；</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">/**/</span></span><br><span class="line">  	arr[<span class="number">100</span>]=<span class="string">'a'</span>;  arr.length;                     <span class="comment">//101;   length是键名最大整数加1</span></span><br><span class="line">  	arr.abc = <span class="string">'abc'</span>;  arr.length;                 <span class="comment">//101;   length与键名整数有关，和其他无关！</span></span><br><span class="line">  	arr.length=<span class="number">0</span>;   arr[<span class="number">0</span>];                          <span class="comment">//undefined;   清空数组的一个有效方法是：length属性设置为0；</span></span><br></pre></td></tr></table></figure>
<p>#二、数组的方法：</p>
<p>###1. Array.isArray(xxx)<br>    参数：xxx是要做判断的对象/数组<br>      返回值：布尔值，判断是数组就返回true，否则是false</p>
<p>###2. Array.from(arrayLike, fn)<br>    参数：arrayLike是类数组对象或可迭代的对象，fn是新数组中的每个元素都会执行该函数<br>       返回值：类数组转化成新数组，返回该数组</p>
<p>###3. Array.of(ele0, ele1….elen)<br>    参数：按顺序成为新数组中的元素，哪怕是单个的数字（备注）<br>       返回值：新数组</p>
<p>###4. array.concat(arr1, arr2…)<br>    参数：被连接的目标数组们（浅拷贝，拷贝的是引用）<br>      返回值：连接多个数组后的新数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> y = [[<span class="number">1</span>,<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">var</span> z = x.concat(y);	<span class="comment">//[0, [1,2]]   z[1]是y的引用，互相影响</span></span><br></pre></td></tr></table></figure>
<p>###5. array.slice()<br>    参数：起始位置（包含），结束位置（不包含），负数代表从后往前第几个元素<br>      返回值：拆分原数组，返回新数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">x.slice();			<span class="comment">//['a', 'b', 'c']; </span></span><br><span class="line">x.slice(<span class="number">0</span>,<span class="number">1</span>);  		<span class="comment">//['a']</span></span><br><span class="line">x.slice(<span class="number">-2</span>);  		<span class="comment">//['b', 'c'] 倒数第2个开始</span></span><br></pre></td></tr></table></figure>
<p>###6. array.join()<br>    参数：元素之间的连接符，默认是逗号<br>       返回值：将数组变成字符串，返回的是该字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]    </span><br><span class="line">x.join();  			<span class="comment">// "a,b,c"</span></span><br><span class="line">x.join(<span class="string">''</span>);  		<span class="comment">// "abc"</span></span><br><span class="line">x.join(<span class="string">'加'</span>)			<span class="comment">// "a加b加c"</span></span><br></pre></td></tr></table></figure>
<p>###7. 字符串.split()<br>    参数：分隔符<br>       返回值：在源字符串以分隔符出现的位置进行分割，分割之后变成新数组，返回该数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"abc"</span>;</span><br><span class="line">x.split(<span class="string">'a'</span>); 		<span class="comment">// ['', 'bc']</span></span><br><span class="line">x.split(<span class="string">'b'</span>);  		<span class="comment">// ['a', 'c']</span></span><br><span class="line">x.split();  		<span class="comment">// ['abc']</span></span><br><span class="line">x.split(<span class="string">''</span>);   		<span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>
<p>###8. array.forEach((item,index)=&gt;{ })<br>    参数：为每个元素执行的函数<br>     返回值：遍历之后，没有返回结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span> ];</span><br><span class="line">x.forEach(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>###9. array.map((item,index)=&gt;{ })<br>    参数：为每个元素执行的函数<br>      返回值：遍历之后，返回新数组           </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span> ];</span><br><span class="line">x.map(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>###10. array.filter((item,index)=&gt;{})<br>    参数：函数，用来过滤数组用的<br>     返回值：过滤之后的新数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x.filter(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123; </span><br><span class="line">	<span class="keyword">return</span> value &gt;= <span class="number">2</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>###11. array.reduce(()=&gt;{}, xx)<br>    参数：每个元素都调用的函数<br>     返回值：为数组中的每个元素应用一个函数，将其减少到单个值     </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x.reduce(<span class="function">(<span class="params">add, value</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add=add+value</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>###12. array.sort((x, y)=&gt;{return x-y})<br>    参数：参数：一个函数（非必须）<br>     返回值：返回排序之后的新数组，原数组被改变了！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span> ];   </span><br><span class="line">x.sort(<span class="function">(<span class="params">x, y</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x-y</span><br><span class="line">&#125;);		<span class="comment">//[1,2,3];       //可能是升序也可能是降序</span></span><br></pre></td></tr></table></figure>
<p>###13. array.indexOf()<br>    参数：要查找的那个元素<br>    返回值：第一个被找到的那个元素在数组中的位置，没找到就返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [ <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span> ]</span><br><span class="line">x.indexof(<span class="string">'a'</span>);	  		<span class="comment">//	0     </span></span><br><span class="line">x.indexof(<span class="string">'c'</span>);  		<span class="comment">//	-1</span></span><br></pre></td></tr></table></figure>
<p>###14. push()<br>    参数：要添加到数组结尾的元素。<br>    返回值：新数组的长度（新的length值）。   也可用于类数组对象！</p>
<p>###15. unshift()<br>    参数：要添加到数组开头的元素。<br>    返回值：新数组的长度（新的length值）。  也可用于类数组对象！</p>
<p>###16. pop()<br>    返回值：数组结尾的已经被删除了的那个元素。</p>
<p>###17. shift()<br>    返回值：数组开头的已经被删除了的那个元素。</p>
<p>#二、数组去重：</p>
<ol>
<li>借助对象属性名<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">-2</span>,<span class="string">'2'</span>, <span class="number">2</span> ,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterArray</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">       <span class="keyword">let</span> newArr = []</span><br><span class="line">       arr.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(obj[item] !== item)&#123;</span><br><span class="line">   	        obj[item]=item</span><br><span class="line">  	            newArr.push(item)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="keyword">return</span> newArr</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li>利用数组的indexof方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterArray</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">   	<span class="keyword">let</span> newArr = []</span><br><span class="line">   	arr.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">       	newArr.indexOf(item) === <span class="number">-1</span> &amp;&amp; newArr.push(item)</span><br><span class="line">   	&#125;)</span><br><span class="line">   	<span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3、Set去重<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br></pre></td></tr></table></figure></p>
<p>#三、数组方法源代码</p>
<p>##1. join方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Join = functio</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">this</span>[<span class="number">0</span>] || <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;<span class="keyword">this</span>.length; i</span><br><span class="line">        result = result + char + </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##2. slice方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Slice = <span class="function"><span class="keyword">function</span>(<span class="params">begin,end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    begin = begin || <span class="number">0</span></span><br><span class="line">    end = end || <span class="keyword">this</span>.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=begin; i&lt;end; i++)&#123;</span><br><span class="line">        result.push(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##3. sort方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Sort = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn = fn || <span class="function"><span class="keyword">function</span> <span class="title">ff</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>; j&lt;<span class="keyword">this</span>.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn.call(<span class="literal">null</span>, <span class="keyword">this</span>[j], <span class="keyword">this</span>[i])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                [<span class="keyword">this</span>[i], <span class="keyword">this</span>[j]] = [<span class="keyword">this</span>[j], <span class="keyword">this</span>[i]]</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##4. forEach方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_ForEach = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        fn.call(<span class="literal">null</span>, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##5. map方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Map = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">            result[i] = fn.call(<span class="literal">null</span>, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##6. filter方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Filter = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn.call(<span class="literal">null</span>, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>))&#123;</span><br><span class="line">               result.push(<span class="keyword">this</span>[i]) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##7. reduce方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Reduce = <span class="function"><span class="keyword">function</span>(<span class="params">fn, init</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = init</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        result = fn.call(<span class="literal">null</span>, result, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-数组（升级）/" data-id="cjowb1ymw000qusqr8bcujhj7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-函数（升级）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-函数（升级）/" class="article-date">
  <time datetime="2018-11-22T08:48:51.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-函数（升级）/">JS-函数（升级）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN、《JS高程》、《JS权威指南》</p>
<p>#一、函数内this是什么？<br><img src="http://piks830x0.bkt.clouddn.com/this%E7%9A%84%E6%9C%AC%E8%B4%A8.png" alt="this的辅助理解"></p>
<p>定义：this是参数，连接JavaScript中的函数和对象</p>
<p>口诀：有call看call，没call看点，没call没点就是window（严格模式特殊考虑），<br>    此口诀对箭头函数均不适用</p>
<p>判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*this指的是call方法的第一个参数，apply和bind方法也一样*/</span></span><br><span class="line">fn.call()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*this指的是obj对象*/</span></span><br><span class="line">obj.fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*this指的是window，如果是严格模式下，就是undefined*/</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*箭头函数内外this一样*/</span></span><br><span class="line">()=&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*this指的是类的实例xx*/</span></span><br><span class="line"><span class="keyword">let</span> xx = <span class="keyword">new</span> ClassName()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*this指的是事件源btn*/</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"><span class="comment">/*this就是btn被调用的那个环境里的this*/</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*this就是window*/</span></span><br><span class="line">myPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"><span class="comment">/*this就是resolve被调用时的环境里的this*/</span></span><br><span class="line">myPromise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>#二、异步和回调<br><img src="http://piks830x0.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E5%BC%82%E6%AD%A5%E7%9A%84%E5%A4%84%E7%90%86.png" alt="图片描述"></p>
<p>##1. 异步和同步？</p>
<ul>
<li>同步：等待结果<ul>
<li>例：让黄牛去买票，然后站着等（同步）</li>
</ul>
</li>
<li>异步：不等待结果<ul>
<li>例：让黄牛去买票（告诉黄牛，你买到票就call我），然后去做别的</li>
</ul>
</li>
</ul>
<p>##2. 异步任务执行机制</p>
<p>同步任务在JS引擎中执行，异步任务交给浏览器监听，<br>碰到同步任务，直接从上到下依次执行，碰到异步任务，扔给浏览器监听是否被激活，<br>JS引擎等到当前任务执行完毕，就把激活的异步任务拿过来执行，<br>如果没有被激活的异步任务，JS引擎继续执行下面的任务。</p>
<p>##3. 异步任务的常见类型</p>
<ul>
<li>事件监听：如click、submit等等</li>
<li>前端请求：如ajax，资源加载等等（如图片，脚本）</li>
<li>定时器：setTimeout( )、setInterval( )</li>
</ul>
<p>##4. 处理异步任务：</p>
<p>####(1) 回调函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">callback</span>)</span>&#123; </span><br><span class="line">    。。。。。（异步任务：事件监听、前端请求、定时器）</span><br><span class="line">    callback( )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123; 。。。。。（任务）&#125;</span><br><span class="line">A(B)</span><br></pre></td></tr></table></figure></p>
<p>####(2) Promise大法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    (resolve,reject)=&gt;&#123;</span><br><span class="line">      	。。。。。（异步任务：事件监听、前端请求、定时器）</span><br><span class="line">    	resolve( )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">myPromise().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;, ()=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>####(3) async/await</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*async函数*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入fn函数'</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'时间到了'</span>)</span><br><span class="line">            resolve(<span class="string">'这里异步返回的结果'</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'fn函数的结果'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*async函数的调用*/</span></span><br><span class="line">fn().then(<span class="function">(<span class="params">xx</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xx)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn函数之后的同步函数'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果*/</span></span><br><span class="line">输出：进入fn函数</span><br><span class="line">输出：fn函数之后的同步函数</span><br><span class="line">输出：时间到了</span><br><span class="line">输出：这里异步返回的结果</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*async函数*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入fn函数'</span>)</span><br><span class="line">       setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'时间到了'</span>)</span><br><span class="line">       &#125;, <span class="number">2000</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'fn函数的结果'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*async函数的调用*/</span></span><br><span class="line">fn().then(<span class="function">(<span class="params">xx</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(xx)</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn函数之后的同步函数'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果*/</span></span><br><span class="line">输出：进入fn函数</span><br><span class="line">输出：fn函数之后的同步函数</span><br><span class="line">输出：fn函数的结果</span><br><span class="line">输出：时间到了</span><br></pre></td></tr></table></figure>
<p>#三、什么是闭包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建闭包*/</span></span><br><span class="line"><span class="keyword">let</span> xx = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> date = <span class="number">100</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> date++</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">/*使用闭包*/</span></span><br><span class="line">xx()</span><br></pre></td></tr></table></figure></p>
<p>##1. 定义：<br>如果一个函数使用了它范围之外的变量，那么这个函数和这个变量就组成了闭包。</p>
<p>##2. 目的：</p>
<ul>
<li>让一个局部变量拥有全局变量的随处可以访问到的优点</li>
<li>而又不拥有全局变量污染全局环境的缺点。</li>
</ul>
<p>##3. 如何使用：</p>
<ul>
<li>定义外层函数，封装被保护的局部变量； </li>
<li>定义内层函数，执行对外部函数变量的操作；</li>
<li>外层函数返回内层函数的地址，此步骤方法有很多！ </li>
</ul>
<p>##4. 何时使用：</p>
<ul>
<li>需要一个全局变量，但又不想定义成全局的，就可以用闭包，<br>  即在函数内定义局部变量，在函数外照用不误！</li>
<li>局部变量：无法共享（函数外无法使用），无法长久保存</li>
<li>全局变量：可能造成变量污染</li>
</ul>
<p>##5. 闭包缺点：<br>占用更多内存，不容易被释放 </p>
<p>#四、自调用函数（IIFE）：</p>
<p>##1. 函数创建之后，立即调用该函数： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">1</span>：!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;()</span><br><span class="line">方式<span class="number">2</span>：;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;())</span><br><span class="line">方式<span class="number">3</span>：;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)()</span><br></pre></td></tr></table></figure>
<p>##2. 存在目的：<br>造出一个全局作用域，防止污染全局变量</p>
<p>##3. 何时使用：</p>
<ul>
<li>1、我们不想要全局变量，所以我们要使用局部变量</li>
<li>2、ES5里面，只有函数有局部变量</li>
<li>3、于是我们声明一个函数function xxx，然后xxx.call( )</li>
<li>4、这个时候，xxx是全局变量（全局函数）</li>
<li>5、所以我们不能给这个函数名字</li>
<li>6、于是写成 !funtion( ){ }.call( ) ，即自调用函数，注意结果被取反了</li>
</ul>
<p>#五、作用域和调用堆栈</p>
<p>##1. 作用域：</p>
<ul>
<li>JS作用域是指变量存在的范围，分为全局作用域、函数作用域、块级作用域。</li>
<li>函数作用域：函数本身作用域是其定义时所处的作用域，而不是其调用时所处的作用域。</li>
<li>作用域链：通过链式查找，可确定哪些数据能被函数访问。</li>
</ul>
<p>##2. 函数声明提升：<br>函数声明可以提升至其所处作用域顶部，函数表达式不可以</p>
<p>##3. 调用堆栈：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数A内部有函数B，函数B内部有函数C*/</span></span><br><span class="line">A()&#123;</span><br><span class="line">    。。。。</span><br><span class="line">    B()&#123;</span><br><span class="line">        。。。。</span><br><span class="line">        C()&#123;</span><br><span class="line">            。。。。</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        。。。。</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    。。。。</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line">A( )</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">计算机在主程从上到下执行，</span><br><span class="line">碰到函数A，进入函数体，从上到下执行，</span><br><span class="line">碰到函数B，进入函数体，从上到下执行，</span><br><span class="line">碰到函数C，进入函数体，从上到下执行，</span><br><span class="line">在函数C内<span class="keyword">return</span>时跳出函数体，回到函数B</span><br><span class="line">在函数B内<span class="keyword">return</span>时跳出函数体，回到函数A</span><br><span class="line">在函数A内<span class="keyword">return</span>时跳出函数体，回到主程</span><br></pre></td></tr></table></figure></p>
<p>#六、高阶函数和柯里化<br><img src="http://piks830x0.bkt.clouddn.com/%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97.png" alt=""></p>
<p><a href="http://piks830x0.bkt.clouddn.com/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.png" target="_blank" rel="noopener">辅助理解</a></p>
<p>##1. 什么是高阶函数？</p>
<ul>
<li>输入一个或多个函数</li>
<li>输出一个函数</li>
<li>满足上面条件之一就是高阶函数，但通常同时满足两个</li>
</ul>
<p>##2. 什么是柯里化？<br>用单参数的函数模拟多参数的函数，调用某函数并传入部分参数，让它返回一个函数去接受剩下的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将f(x, y)变成f(x=<span class="number">1</span>)(y) 或 f(y=<span class="number">1</span>)(x)</span><br></pre></td></tr></table></figure>
<p>##3. 柯里化应用：</p>
<ul>
<li>分批传值：<ul>
<li>假设函数需要传入多个值，可以一个值一个值的传递，</li>
<li>也可以固定某些参数，让余下的参数在已有的参数上运算。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> outerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> innerArgs  = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">let</span> finalArgs = outerArgs.concat(innerArgs)</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">undefined</span>, finalArgs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"><span class="keyword">let</span> curried = curry(add,<span class="number">10</span>)</span><br><span class="line">curried(<span class="number">2</span>)  <span class="comment">//12</span></span><br><span class="line">curried(<span class="number">3</span>)  <span class="comment">//13</span></span><br></pre></td></tr></table></figure>
<ul>
<li>早期模板引擎：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">templatebar</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.replace(<span class="string">'&#123;&#123;name&#125;&#125;'</span>,y.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> curried = templatebar(<span class="string">'&lt;h1&gt;你好，我叫&#123;&#123;name&#125;&#125;&lt;/h1&gt;'</span>)</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">curried(&#123;<span class="attr">name</span>:<span class="string">'张治国'</span>&#125;)</span><br><span class="line"><span class="string">"&lt;h1&gt;你好，我叫张治国&lt;/h1&gt;"</span></span><br><span class="line">curried(&#123;<span class="attr">name</span>:<span class="string">'邢晓栋'</span>&#125;)</span><br><span class="line"><span class="string">"&lt;h1&gt;你好，我叫邢晓栋&lt;/h1&gt;"</span></span><br></pre></td></tr></table></figure>
<p>#七、什么是惰性载入？</p>
<p>##1. 目的<br>提高性能，避免代码重复执行，即让函数的分支仅发生一次</p>
<p>##2. 特点：</p>
<ul>
<li><p>非惰性载入，每次调用fn时都会做判断，降低性能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> kk</span><br><span class="line">    <span class="keyword">if</span>(xx)&#123;</span><br><span class="line">        kk = ABC</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        kk = DEF</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性载入，只在首次调用fn时做判断，以后调用直接使用被分配的东东</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(xx)&#123;</span><br><span class="line">        fn = ABC</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fn = DEF</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性载入，声明的同时调用fn，只在首次调用fn时做判断，以后调用直接使用分配的东东</p>
<pre><code class="js"><span class="keyword">let</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">if</span>(xx){
        fn = ABC
    }<span class="keyword">else</span>{
        fn = DEF
    }
})()
</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-函数（升级）/" data-id="cjowb1ymm000gusqrnz7q3ez8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-函数（基础）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-函数（基础）/" class="article-date">
  <time datetime="2018-11-22T08:48:41.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-函数（基础）/">JS-函数（基础）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN、《JS高程》、《JS权威指南》</p>
<p>#一、函数创建和调用</p>
<p>##1. 函数定义相关问题：</p>
<ul>
<li>函数就是一种可执行代码组成的对象，是一等公民，</li>
<li>即使形式上作为对象的方法存在，也不属于该对象，只是把函数的地址赋值给了对象而已。</li>
</ul>
<p>##2. 函数创建相关问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*具名函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>)</span>&#123;<span class="keyword">return</span> x+y&#125;					<span class="comment">/*函数声明语句*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*匿名函数*/</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y&#125;				<span class="comment">/*匿名函数表达式*/</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">kk</span>(<span class="params">x ,y</span>)</span>&#123; <span class="keyword">return</span> x+y &#125;      	<span class="comment">/*命名函数表达式*/</span></span><br><span class="line"> 	<span class="keyword">let</span> fn = <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x+y'</span>)		<span class="comment">/*构造函数*/</span></span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/*箭头函数*/</span></span><br><span class="line"> 	<span class="keyword">let</span> fn = <span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+y&#125;     	          	<span class="comment">/*箭头函数*/</span></span><br></pre></td></tr></table></figure>
<p>##3. 函数调用相关问题：</p>
<ol>
<li>sum( )，语法糖，不建议使用；</li>
<li>sum.call(sum, 实参)，高手都这么用！</li>
</ol>
<p>##4. 知识补充：</p>
<ul>
<li>用return来指定函数的返回值，如果没有指定，则为undefined，<br>  特殊的构造函数不需要return，但通常要绑定原型</li>
<li>函数创建时为形参，函数调用时为实参，同名参数取后者</li>
<li>不能在非函数代码块中声明函数，比如在 if/else 语句块中、或 try/catch 语句块中；</li>
<li>箭头函数，一个形参时小括号可省略，一个表达式时花括号可省略，return也可省略</li>
<li>参数的值只有在传参的时候确定；this作为call的第一个参数，也是只有传参的时候才确定！</li>
<li>函数体内的this对象，就是定义时所在的对象。</li>
</ul>
<p>#二、函数的属性和方法</p>
<p>##1. 内部的属性</p>
<ol>
<li>this：看难点章节</li>
<li>arguments—-“实参对象（类数组）”</li>
</ol>
<ul>
<li>argument.length—-“实参数量”</li>
<li>arguments.callee—-“在函数内部获取函数自身的引用，也可以用函数名，但出现高耦合！”</li>
<li>caller—-“指向调用当前函数的那个函数”</li>
</ul>
<p>##2. 自带的属性：<br>1、name： 函数名字</p>
<ul>
<li>函数声明语句：sum;</li>
<li>匿名函数表达式：sum;</li>
<li>命名函数表达式：add;</li>
<li>箭头函数：sum;</li>
<li>new Function：anonymous  //匿名的意思</li>
</ul>
<p>2、length：形参数量，即定义时的参数个数。</p>
<p>##3. 其他常用方法：<br><a href="http://piks830x0.bkt.clouddn.com/bind%20call%E7%AD%89%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83.png" target="_blank" rel="noopener">bind和call的使用时比较：例1</a></p>
<p><a href="http://piks830x0.bkt.clouddn.com/bind%20call%E7%AD%89%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%832.png" target="_blank" rel="noopener">bind和call的使用时比较：例2</a></p>
<p>1、call(): </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call( obj, arg1, arg2, ……)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：第一个实参是调用上下文，在函数体内通过this来引用；</li>
<li>其他参数是实参，在函数体内通过argumens类数组来引用。</li>
<li>在普通模式下，call( )的第一个实参是基本类型会变成相应的包装对象，null和undefined会变成window全局对象。</li>
<li>在严格模式下，call( )的第一个实参会变成this的值，即使它是基本类型，甚至是null或undefined，依然如此；</li>
</ul>
<p>2、apply(): </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply( obj, [arg1, arg2, ……] )</span><br></pre></td></tr></table></figure>
<p>3、bind(): 创建函数，指定新函数内this是谁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind( obj, arg1, arg2 )</span><br></pre></td></tr></table></figure>
<ul>
<li>bind()创建新函数，新函数与fun具有相同函数体，</li>
<li>新函数的this就是bind的第一个参数obj，</li>
<li>新函数的参数就是bind的其他参数arg1和arg2</li>
<li>至此，实现了修改fun内this指向的目的，与call和apply目的一致。</li>
<li>因为bind()返回一个新函数，加上括号输入实参才能正常使用，<br>  这一点和call()、apply()不一样！！！</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y, z</span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.x+y+z&#125;;</span><br><span class="line">  	<span class="keyword">let</span> fn = f.bind(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, <span class="number">2</span> , <span class="number">5</span>)()   <span class="comment">/*输出8*/</span></span><br></pre></td></tr></table></figure>
<p>4、eval()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将字符串当做语句执行*/</span></span><br><span class="line"><span class="built_in">eval</span>( <span class="string">"console.log(123)"</span> );    <span class="comment">//输出123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>eval没有自己作用域，都在当前作用域内执行。</li>
<li>普通模式下会修改它所处作用域内变量的值，造成安全问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;   </span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"a=3"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>严格模式下，不会影响外部作用域。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-函数（基础）/" data-id="cjowb1ymn000husqrbport6uy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-对象（升级）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-对象（升级）/" class="article-date">
  <time datetime="2018-11-22T08:08:43.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-对象（升级）/">JS-对象（升级）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN、《JS高程》、《JS权威指南》、<a href="https://zhuanlan.zhihu.com/p/23987456?refer=study-fe" target="_blank" rel="noopener">方应杭-知乎</a></p>
<p>#一、构造函数、原型及原型链</p>
<p>###1. 构造函数是什么？</p>
<ul>
<li>构造函数是特殊的函数，它返回一个对象，</li>
<li>JS引擎会帮我们创建了对象this，并把属性和方法绑定到了this上，最后返回该this，</li>
<li>JS引擎还帮我们绑定原型对象，所有new出来的实例对象会从原型对象上继承属性和方法，</li>
<li>我们用new去调用构造函数</li>
</ul>
<p>###2. 原型是什么？</p>
<ul>
<li>构造函数的prototype属性指向一个对象，该对象内保存着构造函数创造出的所有实例对象共享的属性和方法，该对象就是原型对象，简称原型，原型有个constructor属性，指向构造函数。</li>
</ul>
<p>###3.原型链是什么？</p>
<ul>
<li>基本思想是让一个对象从另一个对象继承属性和方法</li>
<li>属性查找时，先在对象实例上找，找到结束</li>
<li>找不到时，在原型上找，找到结束</li>
<li>找不到时，在原型的原型上找，找到结束</li>
<li>一直找到Object.prototype上，找到结束，没找到则返回undefined </li>
</ul>
<p>###4. 知识补充：</p>
<ul>
<li>原型链的数据结构是树;</li>
<li>Object.prototype对象没有原型，它不继承任何属性；</li>
<li>通过对象字面量创建的对象，原型都是Object.prototype；</li>
<li>通过new+构造函数创建的对象，原型都是构造函数.prototype；</li>
<li>所有内置构造函数都有一个继承自Object.prototype的原型；</li>
</ul>
<p>#二、如何实现继承？<br><img src="http://piks830x0.bkt.clouddn.com/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9B%BE.png" alt=""></p>
<p><a href="http://piks830x0.bkt.clouddn.com/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%20%E6%B3%A8%E6%84%8F%E7%82%B9.png" target="_blank" rel="noopener">写继承的时候注意点</a></p>
<p>###1. ES5中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*假设A向B继承属性和方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">options</span>)</span>&#123;&#125;</span><br><span class="line">B.prototype.sayCountryName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	B.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = <span class="built_in">Object</span>.create(B.prototype)</span><br><span class="line">A.prototype.sayCapitalName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure></p>
<p>###2. ES6中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*假设A向B继承属性和方法*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>()&#123;</span><br><span class="line">		<span class="keyword">this</span>.countryName = <span class="string">'中国'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">		<span class="keyword">super</span>(props)</span><br><span class="line">		<span class="keyword">this</span>.capitalName = <span class="string">'北京'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure></p>
<p><a href="http://piks830x0.bkt.clouddn.com/ES6%20%E7%B1%BB%20%E7%BB%A7%E6%89%BF.png" target="_blank" rel="noopener">ES6类示例</a></p>
<p>#三、类公有、私有和静态的属性和方法</p>
<p>###1. 自有的属性和方法：<br>定义：属性值随着实例的不同而不同，即需要创建实例时所传的参数<br>创建：构造函数里this对象上、ES6的class的constructor函数里</p>
<p>###2. 公有的属性和方法：<br>定义：属性值不随着实例的不同而不同，即不需要创建实例时所传的参数<br>创建：构造函数.prototype对象上、ES6的class的constructor函数外</p>
<p>###3. 静态的属性和方法：<br>定义：构造函数或类中自己使用的，不让实例继承到<br>创建：ES5中用下划线加方法名，ES6中用static关键字</p>
<p>#四、包装对象<br><img src="http://piks830x0.bkt.clouddn.com/%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1.png" alt=""></p>
<p>我们可以通过var nn = new Number(3.14);创建一个数字对象，<br>这个对象nn有很多属性和方法，如保留固定个数小数位、数字转换成字符串等等，<br>但是这种方法太麻烦了！！！</p>
<p>我们可以通过var mm = 3.14; 创建一个数字基本类型，<br>如果能直接在mm上操作就得到上面的结果，该多美好啊！！！</p>
<p>当我们执行mm.toFixed( )和mm.toString( )时，<br>浏览器就自动创建了 PV: 3.14 数字对象，这个数字对象就是包装对象，实际上所有操作都是在这个对象上进行的，<br>操作完毕，对象销毁！并且不影响原来mm的值，即mm=3.14。</p>
<p>数字包装对象、字符串包装对象、布尔值包装对象 原理一样。</p>
<p>把数字基本类型当成对象去操作时，JS引擎自动帮助创建了一个包装对象，当操作完毕的时候，<br>JS引擎会自动销毁该包装对象，并且不影响原来的值，字符串和布尔值也是一样的道理。<br>包装对象三步走：创建对象、操作对象、销毁对象</p>
<p>#五、数据存储及内存图<br><img src="http://piks830x0.bkt.clouddn.com/%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8.png" alt=""></p>
<ul>
<li>变量在代码区，数据在内存区，内存分为Stack栈内存和Heap堆内存；</li>
<li>基本类型数据，被存在Stack栈内存中，存的是值；（按值访问，按值比较）</li>
<li>引用类型数据，被存在Heap堆内存中，然后把它的地址存在Stack中；（按地址访问，按地址比较）</li>
</ul>
<p>案例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把字符串的值赋值给s*/</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"abc"</span></span><br><span class="line"><span class="comment">/*把数组的地址赋值给o*/</span></span><br><span class="line"><span class="keyword">var</span> o = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-对象（升级）/" data-id="cjowb1ymo000iusqrebal36qa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-对象（基础）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-对象（基础）/" class="article-date">
  <time datetime="2018-11-22T07:22:06.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-对象（基础）/">JS-对象（基础）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN文档；《JS高级程序设计》page83页、page138页；《JS权威指南》page118页</p>
<p>#一、对象创建和调用</p>
<p>##1、对象定义： </p>
<ul>
<li>属性的无序集合，每个属性都是一个名/值对；</li>
<li>对象是哈希结构，属性名就是哈希的键名，属性值就是哈希的键值。</li>
<li>除了数字、字符串、布尔值、null和undefined外，JS中的值都是对象</li>
</ul>
<p>##2、对象使用：</p>
<ul>
<li>将对象赋给变量，实际上是将对象在堆内存区中的内存地址赋值给该变量；</li>
<li><p>将对象赋给不同变量，当某个变量修改了对象时，比如属性值，也会影响到其他所有变量；</p>
<ul>
<li>当取消某个变量对该对象的引用时，不会影响其他变量，</li>
<li>取消方法包括将基本类型值赋值给它，或是新建一个对象后赋值给它；</li>
</ul>
</li>
</ul>
<p>##3、对象的创建</p>
<ol>
<li>对象直接量、Object.create(）</li>
<li>工厂模式：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params"> name, age </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123; &#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    obj.age = age</span><br><span class="line">    obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123; alert(<span class="keyword">this</span>.name) &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson( <span class="string">'张治国'</span>, <span class="number">18</span> )</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson( <span class="string">'张小凡'</span>, <span class="number">20</span> )</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>构造函数模式：</li>
</ol>
<p>特点：</p>
<ul>
<li>不用显示的创建对象</li>
<li>自动绑定到原型对象</li>
<li>直接将属性和方法赋值给了this对象</li>
<li>没有return语句</li>
<li>所有实例对象，不共用构造函数内的属性和方法，每次调用，都是在实例对象上重新创建属性和方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123; alert(<span class="keyword">this</span>.name) &#125;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">'xxx'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person( <span class="string">'张治国'</span>, <span class="number">18</span> );</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person( <span class="string">'张小凡'</span>, <span class="number">28</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/*true: 所有实例对象的constructor属性指向同一个构造函数*/</span></span><br><span class="line">alert(person1.constructor === person2.constructor);   </span><br><span class="line"><span class="comment">/*false: 所有实例对象从构造函数继承的属性和方法不是同一个*/</span></span><br><span class="line">alert(person1.sayName === person2.sayName);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>原型模式</li>
</ol>
<p>特点：</p>
<ul>
<li>原型对象自带constructor属性，实例对象继承该属性及属性值</li>
<li>所有实例对象，都共用原型对象内的属性和方法</li>
<li>不能在创建实例之后重写原型，因为会切断实例与新原型之间的联系</li>
<li>修改实例上从原型继承而来的引用类型数据时，其他实例该属性值也会改变，最大缺点！</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.country = <span class="string">"china"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123; alert(<span class="keyword">this</span>.name) &#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person( <span class="string">'张治国'</span>, <span class="number">18</span> )</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person( <span class="string">'张小凡'</span>, <span class="number">28</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">/*true: 原型和实例的constructor指向同一个构造函数*/</span></span><br><span class="line">alert(person1.constructor === Person.prototype.constructor)</span><br><span class="line"><span class="comment">/*true: 所有实例对象从原型对象继承的属性和方法都是同一个*/</span></span><br><span class="line">alert(person1.sayName === person2.sayName)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>构造函数模式+原型模式</li>
</ol>
<p>特点：</p>
<ul>
<li>实例对象自有的属性，在构造函数内创建，自有可以理解为通过传参赋值的那些属性</li>
<li>实例对象共有的属性和方法，在原型对象内创建，共有可以理解为不需要传参赋值的那些属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    country: 'china',</span><br><span class="line">    sayName: function( )&#123; alert(<span class="keyword">this</span>.name) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person( <span class="string">'张治国'</span>, <span class="number">18</span> )</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person( <span class="string">'张小凡'</span>, <span class="number">28</span> )</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>ES6的class创建</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">		<span class="keyword">this</span>.countryName = options.name</span><br><span class="line">	&#125;</span><br><span class="line">	sayCountryName()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.countryName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> contry = <span class="keyword">new</span> Country(&#123;<span class="attr">name</span>: <span class="string">'中国'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>#二、对象的属性和方法（偏概念）：</p>
<p>##1. 属性名相关问题：</p>
<ul>
<li>对象的属性名都是字符串，不是字符串的也转成了字符串；</li>
<li>属性名符合标识符规范或是纯数字时，创建时加不加引号都无所谓；<br>  {name:’张’, ‘age’:18, 0: ‘张’, ‘1’:18}</li>
<li>属性名不符合标识符时，必须加引号；<br>  {‘2b’:250, ‘a b’:’空格’, ‘c+d’:’加号’}</li>
<li>标识符规范：以字母、下划线__或美元符$开头，由字母、下划线、美元符或数字组成；</li>
<li>属性值可以是任意类型，如基本类型的数字、字符串等，引用类型的对象、数组、函数等，<br>  当属性值是函数时，属性名又称为方法；</li>
</ul>
<p>##2. 属性查找相关问题：</p>
<ul>
<li>读取属性时，可以使用点运算符，也可以使用方括号运算符；</li>
<li>使用点运算符：属性名必须符合标识符规范，<br>  如person.name、person.age，person.20报错、person.a+b报错；</li>
<li>使用方括号：除了纯数字外，属性名必须放在引号里面，否则会被当做变量处理，<br>  如obj[1]、obj[‘1’]、obj[‘name’]；</li>
</ul>
<p>##3. 属性增改相关问题：</p>
<ul>
<li>点运算符或是方括号除了可以读取属性外，还可以创建属性和修改属性；</li>
</ul>
<p>##4. 属性删除相关问题：</p>
<ul>
<li>使用delete删除对象的属性，删除成功后返回true；</li>
<li>delete本质是断开属性和对象之间的联系，最终表现的就像是删除一样；</li>
<li>delete只能删除对象的自有属性，不能删除继承属性，否则会报错，继承属性要在原型上才能删除；</li>
<li>读取已经删除的属性和读取不存在的属性一样，都返回undefined；</li>
</ul>
<p>##5. 种类和特性相关问题</p>
<ul>
<li><p>对象种类：</p>
<ul>
<li>内置对象：ECMAScript规范定义的对象，如数组、函数、日期和正则表达式；</li>
<li>宿主对象：JS解释器所嵌入的宿主环境（比如Web浏览器）定义的对象；</li>
<li>自定义对象：运行中的JS代码创建的对象；</li>
</ul>
</li>
<li><p>对象特性：</p>
<ul>
<li>对象的原型：指向另外一个对象，对象的属性从他的原型继承；</li>
<li>对象的类：对象所属类型；</li>
<li>对象的扩展标记：是否可以向该对象添加新属性；</li>
</ul>
</li>
<li><p>属性种类：</p>
<ul>
<li>自有属性：直接在对象中定义的属性；</li>
<li>继承属性：在对象的原型对象中定义的属性；</li>
</ul>
</li>
<li><p>属性特性：</p>
<ul>
<li>可写：表明是否可以设置该属性的值；</li>
<li>可枚举：表明是否可以通过for/in循环返回该属性；</li>
<li>可配置:表明是否可以删除或修改该属性</li>
</ul>
</li>
</ul>
<p>#三、补充：</p>
<ol>
<li>new Function()和Function()，new Array()和Array()，new Object()和Object()<br> 都是两两等价的，创造的都是引用类型，</li>
<li>new String()和String()，new Number()和Number()<br> 是不一样的，前面创造的是引用类型，后面创造的是基本类型；</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-对象（基础）/" data-id="cjowb1ymp000jusqragxo9xv9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS-小图标全解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/CSS-小图标全解/" class="article-date">
  <time datetime="2018-11-22T05:44:56.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/CSS-小图标全解/">CSS-小图标全解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont网站</a></p>
<p>#一、<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont网站</a></p>
<p>###1、Unicode方式：</p>
<ul>
<li>选Unicode</li>
<li>点Click ….. Code生成代码</li>
<li>复制进Style里面</li>
<li>引用图标<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&amp;#xeXXX;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://piks830x0.bkt.clouddn.com/icon-html1.png" target="_blank" rel="noopener">Unicode方式：生成</a></p>
<p><a href="http://piks830x0.bkt.clouddn.com/icon-html2.png" target="_blank" rel="noopener">Unicode方式：使用</a></p>
<p>###2、Font class方式：</p>
<ul>
<li>选Font class</li>
<li>点Click ….. Code生成代码</li>
<li>复制进link里面</li>
<li>引用图标<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont icon-XXX"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://piks830x0.bkt.clouddn.com/icon-css1.png" target="_blank" rel="noopener">Font class方式：生成</a></p>
<p><a href="http://piks830x0.bkt.clouddn.com/icon-css2.png" target="_blank" rel="noopener">Font class方式：使用</a></p>
<p>###4、Symbol方式：</p>
<ul>
<li>选Symbol</li>
<li>点Click…. Code生成代码</li>
<li><p>复制进html文件head标签里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="comment">//at.alicdn.com/t/font_000000.js&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS代码段复制进样式表里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">	 <span class="selector-class">.icon</span> &#123;</span><br><span class="line">		 <span class="attribute">width</span>: <span class="number">1em</span>; <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">		 <span class="attribute">vertical-align</span>: -<span class="number">0.15em</span>;</span><br><span class="line">		 <span class="attribute">fill</span>: currentColor;</span><br><span class="line">		 <span class="attribute">overflow</span>: hidden;</span><br><span class="line">	 &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>html代码段复制进html文档中（最好方式）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://piks830x0.bkt.clouddn.com/icon-js1.png" target="_blank" rel="noopener">Symbol方式：生成</a></p>
<p><a href="http://piks830x0.bkt.clouddn.com/icon-js2.png" target="_blank" rel="noopener">Symbol方式：使用</a></p>
<p>#二、制作PSD/PNG设计稿：</p>
<ul>
<li>PS软件打开</li>
<li>新建画布</li>
<li>移入图标</li>
<li>调整大小摆放位置</li>
<li>保存文件.PSD或者.PNG</li>
</ul>
<p>###1.PSD设计稿：</p>
<ul>
<li>PS软件打开</li>
<li>选中目标icon</li>
<li>复制图层（新建）</li>
<li>菜单图像选剪切</li>
<li>菜单图像选画布大小 100*100</li>
<li>菜单文件选导出</li>
<li>快速导出为PNG</li>
</ul>
<p>###2.PNG设计稿：</p>
<ul>
<li>PS软件打开</li>
<li>选框工具粗选</li>
<li>菜单图像裁剪</li>
<li>魔棒工具选择/反选</li>
<li>Delete键删除</li>
<li>菜单图像选剪切</li>
<li>菜单图像选画布大小 100*100</li>
<li>菜单文件选导出</li>
<li>快速导出为PNG</li>
</ul>
<p>#三、Sprites雪碧/精灵图：</p>
<ul>
<li>打开网站</li>
<li>选择文件</li>
<li>设置输出类型、class类前缀、icon间距</li>
<li>创建雪碧图</li>
<li>开始使用：图片下载、CSS代码复制粘贴、HTML代码复制粘贴</li>
</ul>
<p>#四、纯CSS方法：svg</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/CSS-小图标全解/" data-id="cjowb1ymc0007usqruqruog1x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/23/数据结构和算法/">数据结构和算法</a>
          </li>
        
          <li>
            <a href="/2018/11/23/JS-Canvas/">JS-Canvas</a>
          </li>
        
          <li>
            <a href="/2018/11/23/网络安全/">网络安全</a>
          </li>
        
          <li>
            <a href="/2018/11/23/前后端交互/">前后端交互</a>
          </li>
        
          <li>
            <a href="/2018/11/23/HTTP-基础/">HTTP-基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 张治国<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>