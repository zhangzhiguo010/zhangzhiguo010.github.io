<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>resume | 张治国的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#2018.11月准备面试： ##面试经验： ##十六、sort函数使用什么算法？1234567891011Array.prototype.my_Sort = function(fn)&amp;#123;    fn = fn || function ff(a,b)&amp;#123;return a-b&amp;#125;    for(let i=0; i&amp;lt;this.length-1; i++)&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="resume">
<meta property="og:url" content="http://yoursite.com/2018/11/27/resume/index.html">
<meta property="og:site_name" content="张治国的博客">
<meta property="og:description" content="#2018.11月准备面试： ##面试经验： ##十六、sort函数使用什么算法？1234567891011Array.prototype.my_Sort = function(fn)&amp;#123;    fn = fn || function ff(a,b)&amp;#123;return a-b&amp;#125;    for(let i=0; i&amp;lt;this.length-1; i++)&amp;#123;">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-11-26T16:15:11.697Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="resume">
<meta name="twitter:description" content="#2018.11月准备面试： ##面试经验： ##十六、sort函数使用什么算法？1234567891011Array.prototype.my_Sort = function(fn)&amp;#123;    fn = fn || function ff(a,b)&amp;#123;return a-b&amp;#125;    for(let i=0; i&amp;lt;this.length-1; i++)&amp;#123;">
  
    <link rel="alternate" href="/atom.xml" title="张治国的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张治国的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-resume" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/27/resume/" class="article-date">
  <time datetime="2018-11-26T16:14:50.000Z" itemprop="datePublished">2018-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      resume
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#2018.11月准备面试：</p>
<p>##面试经验：</p>
<p>##十六、sort函数使用什么算法？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Sort = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn = fn || <span class="function"><span class="keyword">function</span> <span class="title">ff</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>; j&lt;<span class="keyword">this</span>.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn.call(<span class="literal">null</span>, <span class="keyword">this</span>[j], <span class="keyword">this</span>[i])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                [<span class="keyword">this</span>[i], <span class="keyword">this</span>[j]] = [<span class="keyword">this</span>[j], <span class="keyword">this</span>[i]]</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>冒泡排序和插入排序的混合</li>
</ul>
<p>##十五、HTTP和HTTPS的区别？</p>
<ul>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>
<li></li>
</ul>
<p>##十四、web性能优化<br><a href="https://github.com/creeperyang/blog/issues/1" target="_blank" rel="noopener">雅虎前端优化35条规则翻译</a></p>
<ol>
<li>浏览器缓存： 使用cache-control max-age=1</li>
<li>使用CDN加速，CDN就是内容分发</li>
<li><p>使用gzip报文压缩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*客户端*/</span></span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"><span class="comment">/*服务器*/</span></span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用图片压缩，PS</p>
</li>
<li>使用webpack进行打包，减少文件请求数量</li>
<li>懒加载，在可视区域内才加载</li>
</ol>
<p>##十三、在html里控制缓存？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Expires"</span> content=<span class="string">"0"</span> /&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Cache-control"</span> content=<span class="string">"no-cache"</span> /&gt;</span><br><span class="line"></span><br><span class="line">Cache-control时content属性值：</span><br><span class="line">no-cache，浏览器和缓存服务器都不应该缓存页面信息；</span><br><span class="line">Expires，GMT格式，指浏览器或缓存服务器在截止日期后从真正的服务器中获取新的页面信息；</span><br></pre></td></tr></table></figure></p>
<p>##十二、数组有哪些方法？</p>
<p>##十一、什么是mixin？</p>
<ul>
<li>mixin是”混入“、“混合”，将一个对象的属性复制给另一个对象。</li>
<li>功能上类似于Object.assign({}, obj1, obj2)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mixin = <span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> b)&#123;</span><br><span class="line">		a[key] = b[key]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##十、什么是继承？</p>
<ul>
<li>继承使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码</li>
<li>JS里有ES5的函数式继承和ES6的类继承</li>
</ul>
<p>##九、prototype属性的作用：</p>
<ul>
<li>存放共有属性的地址</li>
</ul>
<p>##八、什么是柯里化？</p>
<ul>
<li>用单参数函数模拟多参数函数</li>
<li>调用某函数并传入部分参数，让它返回一个函数去接受剩下的参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*普通函数*/</span></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="function">(<span class="params">x, y</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"><span class="comment">/*柯里化函数*/</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">y</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##七、什么是高阶函数？</p>
<ul>
<li>输入一个或多个函数</li>
<li>输出一个函数</li>
<li>满足上面条件之一就是高阶函数，但通常同时满足两个</li>
</ul>
<p>补充：</p>
<ol>
<li>什么是高阶组件？</li>
</ol>
<ul>
<li>接收一个组件，返回一个新的组件，典型的就是react-redux库中引入的connect函数</li>
</ul>
<p>##六、什么是纯函数？</p>
<ul>
<li>函数的返回结果只依赖于它的参数</li>
<li>函数执行过程里面没有副作用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*纯函数*/</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">x, y</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*不是纯的*/</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">x, a</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+a&#125;		<span class="comment">// a值的改变，会影响函数输出结果</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*纯函数*/</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">obj, y</span>)=&gt;</span>&#123;<span class="keyword">return</span> obj.x + y&#125;</span><br><span class="line"><span class="keyword">const</span> object = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">fn(object, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*不是纯的*/</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">obj, y</span>)=&gt;</span>&#123;</span><br><span class="line">	obj.x = <span class="number">10</span>					<span class="comment">// 修改了外部传进来的变量，而不只是单纯的使用</span></span><br><span class="line">	<span class="keyword">return</span> obj.x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> object = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">fn(object, y)</span><br></pre></td></tr></table></figure>
<p>##五、环信？</p>
<p>环信API用的是XMPP协议，XMPP是一种类似于HTTP协议的数据传输协议，传输的数据都是XML格式的。</p>
<p>工作原理：</p>
<ol>
<li>客户端1连接到服务器</li>
<li>服务器对其认证</li>
<li>客户端1指定客户端2的地址，让服务器去查找</li>
<li>服务器查找、链接并进行相互认证，成功后</li>
<li>客户端1和客户端2就可以进行交互啦</li>
</ol>
<p>特点：</p>
<ul>
<li>XMPP允许客户端、服务器和网关，三者之间消息互通。</li>
<li>客户端：发送和接收消息的设备</li>
<li>服务器：实现了客户端的信息记录、信息路由、链接管理功能</li>
<li>网关：实现了不同的通信系统间交换信息，实现该功能的服务器在XMPP架构里被称作网关</li>
</ul>
<p>##四、canvas基本用法：<br>1、准备工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*html文件中，创建canvas元素*/</span></span><br><span class="line">&lt;canvas width=<span class="string">'300'</span> height=<span class="string">'150'</span> id=<span class="string">'canvas'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span>  <span class="comment">// 注意width和height</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*js文件中，将该元素转化成对象*/</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#canvas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用getContext()方法，得到绘图上下文*/</span></span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>)</span><br></pre></td></tr></table></figure>
<p>2、矩形</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的矩形*/</span></span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.fillRect(x, y, width, height)</span><br><span class="line"><span class="comment">// x、y: 分别是起点X轴和y轴坐标</span></span><br><span class="line"><span class="comment">// width、heigth: 分别是矩形的宽度和高度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的矩形*/</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeRect(x, y, width, height)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*清除矩形部分内容*/</span></span><br><span class="line">context.clearRect(x, y, width, height)</span><br></pre></td></tr></table></figure>
<p>3、三角形</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的三角形*/</span></span><br><span class="line">context.beginPath()			<span class="comment">// 开始画画</span></span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.moveTo(x, y)		<span class="comment">// 起始点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.fill()				<span class="comment">// 填充</span></span><br><span class="line">context.closePath()			<span class="comment">// 结束画画</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的三角形*/</span></span><br><span class="line">context.beginPath()			<span class="comment">// 开始画画</span></span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.moveTo(x, y)		<span class="comment">// 起始点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 想要闭合，x和y是起始点；不想闭合，不用此lineTo()</span></span><br><span class="line">context.stroke()			<span class="comment">// 描边</span></span><br><span class="line">context.closePath()			<span class="comment">// 结束画画</span></span><br></pre></td></tr></table></figure>
<p>4、圆形/圆弧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的圆形*/</span></span><br><span class="line">context.beginPath()</span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">context.fill()</span><br><span class="line">context.closePath()</span><br><span class="line"><span class="comment">// x、y: 圆心x轴和y轴坐标</span></span><br><span class="line"><span class="comment">// radius: 半径</span></span><br><span class="line"><span class="comment">// startAngle、endAngle: 圆弧的起点和终点，Math.PI是π</span></span><br><span class="line"><span class="comment">// anticlockwise：true为顺时针、false为逆时针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的圆形*/</span></span><br><span class="line">context.beginPath()</span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">context.stroke()</span><br><span class="line">context.closePath()</span><br></pre></td></tr></table></figure>
<p>##三、== 和 === 间的区别是什么？<br>1、 </p>
<ul>
<li>==： 相等运算符，类型相同直接比较，比较的是数值，类型不同先转换后比较</li>
<li>===：全等运算符，类型相同直接比较，比较的是地址，类型不同直接false</li>
</ul>
<p>2、相等运算符的转换规则：</p>
<p>（1）基本类型相互间比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*null和undefined不做类型转换，但null和undefined相等；*/</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="number">1</span>				<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="string">'1'</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="literal">true</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="literal">false</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>				<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数字和字符串，字符串被Number()函数转成了数字*/</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'1'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'01'</span>			<span class="comment">// 正确		1 == 01</span></span><br><span class="line"><span class="comment">/*数字和布尔值，布尔值被Number()函数转成了数字*/</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'false'</span>		<span class="comment">// 正确		0 == 0</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'true'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串和布尔值，字符串和布尔值都被Number()函数转成了数字*/</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'1'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'0'</span>		<span class="comment">// 正确		0 == 0</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'123'</span>		<span class="comment">// 错误		1 == 123</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'123'</span>		<span class="comment">// 错误		0 == 123</span></span><br></pre></td></tr></table></figure>
<p>（2）引用类型间相互比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*比较的是地址，地址相同的情况*/</span></span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">age</span>: <span class="number">28</span>&#125;	<span class="comment">//假 地址：100</span></span><br><span class="line"><span class="keyword">let</span> d = c			<span class="comment">//假 地址：100</span></span><br><span class="line">c == d				<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*比较的是地址，地址不同的情况*/</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;	<span class="comment">//假 地址：101</span></span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;	<span class="comment">//假 地址：102</span></span><br><span class="line">a == b				<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>（3）基本类型和引用类型比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对象和数字：对象转成数字*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="number">0</span>			<span class="comment">// 正确		0 == 0</span></span><br><span class="line">[<span class="number">123</span>] == <span class="number">123</span>		<span class="comment">// 正确		123 == 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象和字符串：对象转成字符串*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="string">'0'</span>			<span class="comment">// 正确		'0' == '0'</span></span><br><span class="line">[<span class="number">123</span>] == <span class="string">'123'</span>		<span class="comment">// 正确		'123' == '123'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象和布尔值，对象和布尔值都转成了数字*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="literal">true</span>		<span class="comment">// 错误		0 == 1</span></span><br><span class="line">[<span class="number">0</span>] == <span class="literal">false</span>	<span class="comment">// 正确		0 == 0</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">true</span>		<span class="comment">// 正确		1 == 1</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">false</span>	<span class="comment">// 错误		1 == 1</span></span><br><span class="line">[<span class="number">123</span>] == <span class="literal">true</span>	<span class="comment">// 错误		123 == 1</span></span><br></pre></td></tr></table></figure>
<p>3、(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 可能为 true 吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*a会自动调用toString()方法，该方法被我重写了*/</span></span><br><span class="line">a = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  toString()&#123;</span><br><span class="line">    a.value += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a.value </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#二、em和rem的区别：<br>em: 当前元素的font-size值，font-size值是自己设定的或者从父元素继承的。<br>rem: 根元素的font-size值，根元素是html元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心：屏幕宽度 == <span class="number">10</span>rem</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">`&lt;style&gt;html&#123; font-size: <span class="subst">$&#123;<span class="built_in">window</span>.innerWidth<span class="regexp">/10&#125;px &#125;&lt;/</span>style&gt;<span class="string">`)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        （除以10而不是100是因为：方便计算、浏览器font-size最小是12px）</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">实战：屏幕宽度为500px，元素1宽度为100px，元素2宽度为300px，如何用rem表示？</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">          元素1：px单位：100/500 * 500px     rem单位：100/500 * 10rem</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">          元素2：px单位：300/500 * 500px     rem单位：300/500 * 10rem</span></span></span></span><br></pre></td></tr></table></figure>
<p>##一、opacity 和 rgba()有什么不同？<br>opacity：影响当前元素和其后代元素的透明度。<br>rgba(): 影响当前元素的透明度，不影响后代元素。<br>filter: opacity(): 和opacity一样</p>
<p>filter滤镜属性：高斯模糊、亮度、对比度、饱和度、透明度、灰度、颜色反转、阴影<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter: blur()  <span class="comment">//高斯模糊，默认是0，值越大越模糊</span></span><br><span class="line">filter: brightness()  <span class="comment">//明暗度，默认是100%，小于100%则暗，大于100%则亮</span></span><br><span class="line">filter: contrast()	<span class="comment">//对比度，默认是1，小于100%对比强烈，大于100%对比更低</span></span><br></pre></td></tr></table></figure></p>
<p>#React框架：</p>
<p>##一、React的基本组成单位是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>基本组成单位是元素，元素可以是HTML的原生的标签，也可以是自定义组件</li>
</ol>
<ul>
<li>原生的标签：const element = <div>哈哈</div></li>
<li>自定义组件：const element = <welcome name="zhang"></welcome></li>
</ul>
<p>##二、JSX是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>JSX是JavaScript和XML混合后的新语法，看着像html，实际上是js。</li>
<li>JSX可以防止XSS攻击，原因是在渲染之前都被转化成了字符串。</li>
<li>Babel编译JSX的时候实际上是在调用React.createElement()函数，该函数的三个参数分别是标签名、属性对象和标签内容</li>
</ul>
<p>##三、React如何渲染元素：</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>首先用JSX创建一个虚拟的dom元素</li>
<li>然后调用ReactDOM的render方法，将虚拟的dom插入到页面里</li>
</ul>
<p>##四、React组件的定义？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>React组件本质就是函数，接收输入值，返回React元素；</li>
<li>在ES5中是函数式组件，在ES6中是的类组件</li>
</ul>
<p>##五、React组件的生命周期？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>生命周期分为三个阶段</li>
<li>装载阶段有：constructor、componentWillMount、componentDidMount</li>
<li>更新阶段有：componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate</li>
<li>卸载阶段有：componentWillUnmount</li>
</ul>
<p>常用的声明周期是？</p>
<ul>
<li>componentWillMount：发送ajax请求，向后端要数据；  <pre><code>如果想在标签上直接绑定事件（DOM0），就在这里定义事件处理函数
</code></pre></li>
<li>componentDidMount：通过addEventListener方式绑定事件放在这个函数里（DOM2）</li>
<li>shouldComponentUpdate：决定是否要更新，来提高组件性能，返回true就向下执行，否则不执行</li>
<li>componentWillUnmount：在这里取消定时器，取消事件监听，防止内存泄漏</li>
</ul>
<p>##六、React单向数据流？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>父组件通过props向子组件传递数据，这个props原则上是只读的，子组件不能更改；</li>
</ul>
<p>##七、虚拟DOM？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>浏览器首次渲染，会将html转化成dom树，html中的标签和dom树中的节点一一对应。</li>
<li>浏览器更改页面，如果直接操作dom树上的节点，会引起浏览器对网页进行重新布局，重新绘制，性能很差。</li>
<li>于是我们在JavaScript空间里创建虚拟dom树，组件渲染的时候，会将这次的虚拟dom树和上一次渲染的虚拟dom树进行对比，找到被修改的地方，然后通过ReactDOM.render方法去修改浏览器空间里的真实dom树的相应位置。</li>
</ul>
<p>##八、你了解redux吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li><p>Redux帮助React做数据管理，组件自己用到的数据就放到自己的constructor函数里state对象中，组件之间共享的数据交给redux</p>
</li>
<li><p>组件怎么从store中得到数据呢？调用store的getState方法就可以了。</p>
</li>
<li><p>组件怎么修改store中的数据呢？调用store的dispatch方法并传入action作为参数就可以了。</p>
</li>
<li><p>store是怎么来的呢？store是导入redux文件后获得createStore函数，调用该函数传入reducer作为参数就得到了store</p>
</li>
<li><p>reducer是什么呢？它是一个函数，接收初始数据和action作为参数，根据action的类型，更改数据。store的数据树就是由reducer中的初始数据共同组成了。</p>
</li>
<li><p>action是什么呢？它是一个带着类型和数据的对象。</p>
</li>
<li><p>dispatch做了什么呢？它做了两件事，一个是调用reducer函数并传入action参数，修改store的状态树；另一个就是调用subscribe传过来的监听函数。</p>
</li>
<li><p>subscribe函数是store对象的方法，专门提供reducer函数修改完数据以后要做的任务，通常是调用store的getState方法得到最新的数据然后渲染页面。</p>
</li>
</ul>
<p>##九、你了解react-redux吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>redux可以用于任何框架，而react-redux是专门帮助react做数据管理的</li>
<li>react-redux经常被用到的是Provider组件和connect函数，</li>
<li><p>假设组件A向子组件B传递数据，  </p>
<p>我认为Provider组件是组件A的助手，帮助发送数据的。<br>用法是：将Provider组件作为根组件，并传递store属性给Provider组件。  </p>
<p>我认为connect函数是组件B的助手，帮助接收或修改数据。<br>用法是：在声明组件B的地方用修饰符的方式调用connect函数，传入两个参数，第一个参数使组件能够接收到store的数据。第二个参数使组件获得store的dispatch方法，也就是修改store数据能力。 </p>
</li>
</ul>
<p>##十、hashHistory和browserHistory的区别？</p>
<ol>
<li>url地址不同： </li>
</ol>
<ul>
<li>使用hashHistory,浏览器的url是这样的：/#/user/liuna?_k=adseis</li>
<li>使用browserHistory,浏览器的url是这样的：/user/liuna</li>
</ul>
<ol start="2">
<li>是否发送请求：</li>
</ol>
<ul>
<li>使用hashHistory，不发送请求</li>
<li>使用browserHistory，向服务器发送请求，所以需要服务器的支持</li>
</ul>
<ol start="3">
<li>404错误：</li>
</ol>
<ul>
<li>用户手动刷新页面，hashHistory不会报404错误，browserHistory会报404错误</li>
<li>browserHistory需要后台服务器做路由配置，如果没做的话，用户手动刷新就会报错。</li>
<li></li>
</ul>
<p>#Webpack工程化部分：</p>
<p>##一、转义出的文件过大怎么办？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li><p>使用代码分离技术，具体有两种方法，一种是入口起点，一种是按需加载</p>
</li>
<li><p>入口起点：</p>
</li>
</ol>
<ul>
<li>原来在src目录下创建index.js作为入口文件，webpack编译后生成index.bundle.js文件</li>
<li>现在创建index.js和another.js两个入口文件，webpack编译后生成index.bundle.js和another.bundle.js两个文件，</li>
<li>优点：做到了将大的文件拆分成相对小一点的文件，让浏览器并行加载</li>
</ul>
<p>入口起点有个缺点就是在编译后的文件里存在重复加载模块，解决办法就是将重复的模块放入公共的文件xx中，编译后会第一个xx.bundle.js。 </p>
<ol start="3">
<li>按需加载：</li>
</ol>
<ul>
<li>原来import导入的模块都被编译进了index.bundle.js文件里，导致编译后的文件过大，</li>
<li>通过import导入模块后.then里去使用该模块，编译的时候该模块只会进入xx.bundle.js中，xx.bundle.js和index.bundle.js共同被引入index.html中</li>
<li>import(‘/react’).then((react)=&gt;{正常使用})</li>
</ul>
<p>##二、转义速度过慢怎么办？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、</p>
<p>##三、写过webpack loader吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、没有写过，但是我知道大概的过程<br>2、</p>
<p>#算法部分：</p>
<p>##一、简述排序算法（冒泡排序、选择排序、计数排序、快速排序、插入排序、归并排序）</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、</p>
<p>##二、简述二分查找法？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、</p>
<p>#网络安全部分：</p>
<p>##一、什么是XSS攻击？如何预防？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>XSS是跨站脚本攻击，是一种安全漏洞，</li>
</ol>
<ul>
<li>攻击者在网站上注入恶意的客户端代码，</li>
<li>被攻击者登陆网站时就会自动运行这些恶意代码。</li>
</ul>
<ol start="2">
<li>预防方法有：</li>
</ol>
<ul>
<li>innerHTML改成innerText</li>
<li><p>把所有用户输入的内容中诸如“&lt; &gt; &amp;”等特殊的字符进行转义，不让它作为脚本代码正常运行，</p>
<p>  把 &lt; 替换成 ‘&amp;lt ;’<br>  把 &gt; 替换成 ‘&amp;gt ;’<br>  把 &amp; 替换成 ‘&amp;amp ;’<br>  把 ‘ 替换成 ‘&amp;apos’<br>  把 “ 替换成 ‘’</p>
</li>
<li>用户输入的恶意代码： 《script type=’text/javascript’&gt;alert(‘恶意代码’)<br>转换后：”&lt;scripttype=’text/javascript’&gt;alert(‘恶意代码’)&lt;/script&gt;”<br>好用函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeSafe</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">	<span class="keyword">if</span>(div.innerText)&#123;</span><br><span class="line">		div.innerText = str</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		div.textContent = str	<span class="comment">//支持火狐</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> div.innerHTML</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##二、什么是CSRF攻击？如何预防？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>CSRF是跨站请求伪造</li>
</ol>
<ul>
<li>用户首先登陆一个A网站，并得到cookie,</li>
<li>在没有退出A网站的情形下，访问黑客网站，</li>
<li>黑客网站会带着cookie信息自动访问A网站，执行恶意操作。</li>
</ul>
<ol start="2">
<li>预防方法有：</li>
</ol>
<ul>
<li>除了cookie验证外，还要验证请求报文中的Referer字段，如果不是自己网站的请求就拒绝执行。</li>
<li>验证cookie以外的信息，如添加手机短信验证或者token验证。</li>
<li>设置cookie的时候，设置HttpOnly，让JS不能读取到cookie</li>
</ul>
<p>#HTTP部分：</p>
<p>##一、Cookie是什么？Session是什么？二者之间有什么联系？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>一、cookie：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>cookie用来记录用户数据，cookie被保存在浏览器本地</li>
</ul>
<ol start="2">
<li>使用过程：</li>
</ol>
<ul>
<li>用户登录成功以后，</li>
<li>服务器通过Set-Cookie设置cookie，cookie值就是用户信息，</li>
<li>之后浏览器每次访问服务器，都会带上cookie，读取cookie就得到了用户的信息</li>
</ul>
<ol start="3">
<li>有效期：</li>
</ol>
<ul>
<li><p>cookie默认是关闭浏览器就消失，但是我们可以在服务器中通过Max-Age设置有效期或者通过Expires设置过期日期。</p>
</li>
<li><p>服务器通过cookie中保存的用户信息和数据库中保存的所有用户信息做个比对，就知道是哪个用户了。</p>
</li>
</ul>
<p>二、session：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>session用来记录用户数据，session本质是哈希表，里边是一个个键值对，键名就是随机数sessionId，键值就是用户的信息。</li>
</ul>
<ol start="2">
<li>使用过程：</li>
</ol>
<ul>
<li>用户通过浏览器登录服务器成功以后，</li>
<li>服务器通过Set-Cookie设置cookie，cookie值就是sessionId</li>
<li>之后浏览器每次访问服务器，都会带上cookie，读取cookie得到sessionId，然后在session哈希表中就得到了用户的信息。</li>
</ul>
<ol start="3">
<li>有效期：</li>
</ol>
<ul>
<li>session被存在服务器的内存中，服务器重新启动就会消失，所以我们重启服务器的时候都要备份一下session。</li>
</ul>
<p>三、cookie和session有什么联系？<br>session基于cookie实现的，<br>如果cookie不搭配session使用，那么cookie值就是用户的信息，该信息被明文暴露在了浏览器上，可以被更改也可以被容易的看到，很不安全，<br>如果搭配session使用，那么cookie值就是sessionId这个随机数，用户的信息是session哈希表中sessionId对应的值，该信息保存在服务器中，不会暴露给浏览器，所以安全。</p>
<p>##二、LocalStorage 是什么？SessionStorage是什么？二者之间有什么区别？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>一、LocalStorage：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>LocalStorage是本地存储，存储一些不用考虑安全性的信息，如是否提示过用户，像账号、密码等不能存在这里</li>
</ul>
<ol start="2">
<li><p>使用方法：</p>
<p> localStorage.setItem(‘名’, ‘值’)           //存值<br> localStorage.getItem(‘名’)                 //取值<br> localStorage.removeItem(‘名’)              //删值<br> localStorage.clear( )                     //清空</p>
</li>
<li><p>有效期：</p>
</li>
</ol>
<ul>
<li>永久有效，除非用户清理缓存</li>
</ul>
<ol start="4">
<li>补充：</li>
</ol>
<ul>
<li>只有相同域名的页面才能互相读取localStorage（没有同源那么严重）</li>
<li>localStorage跟HTTP无关，HTTP不会带上localStorage</li>
<li>每个域名最大存储量大概是10MB，浏览器不同数值不同</li>
</ul>
<p>二、SessionStorage：</p>
<ol>
<li>大体上和LocalStorage是一样的，只是有效期不一样，SessionStorage的有效期是页面关闭后失效，而LocalStorage永久有效，除非用户清理缓存</li>
</ol>
<p>##补充：indexDB是什么？</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>数据存储用的，cookie最大存4kb，localStorage和sessionStorage最大存10MB，都太小了</li>
<li>储存空间大：不少于250MB</li>
<li>哈希表结构，键值对存储</li>
<li>同源限制，网页只能访问自身域名下的数据库，而不能访问跨域的数据库</li>
</ul>
<p>##三、JSONP是什么？Ajax是什么？二者之间有什么区别？</p>
<p>一、JSONP：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>发送http请求</li>
</ul>
<ol start="2">
<li><p>使用方法：</p>
<p> let script = document.createElement(‘script’)<br> script.src = <code>/abc?callback${function(responseData){alert(responseData)}}</code><br> document.body.appendChild(script)</p>
</li>
</ol>
<blockquote>
<p>回答：  </p>
<ul>
<li>创建一个script标签并指定scr属性，src属性上加上回调函数  </li>
<li>将script标签添加到body中，同时，自动向后端发送请求  </li>
<li>接收到响应体，自动执行回调函数，回调函数的参数就是前端想要的数据</li>
</ul>
</blockquote>
<p>二、Ajax：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>发送http请求，实现了页面的局部刷新</li>
</ul>
<ol start="2">
<li>使用方法：</li>
</ol>
<ul>
<li>通过创建XMLHttpRequest对象，并调用onreadystatechange属性、open方法和send方法来发送请求。 </li>
</ul>
<p>三、两者之间有什么区别？</p>
<ul>
<li>都是前端向后端请求数据的技术，也都实现了局部刷新，也都对数据类型没有限制</li>
<li>JSON是动态创建<script>标签，AJAX是创建XMLHttpRquest对象</li>
<li>JSONP只能GET，AJAX能GET能POST</li>
<li>JSONP能跨域请求数据，AJAX不能，服务器端CORS(跨站资源共享)技术可以解决跨域问题</li>
</ul>
<p>##四、Cache-Control是什么？ETag是什么？两者之间有什么区别？</p>
<p>一、Cache-Control：</p>
<ul>
<li>Cache-Control是缓存控制，是服务器设置，它是为了提高web性能而存在的。</li>
<li>在有效期内发起请求，浏览器从本地读取资源，</li>
<li>在有效期外发起请求，浏览器从服务器得到资源，</li>
<li>如果想在有效期内从服务器下载资源，我们修改路径上的查询参数</li>
<li>有效期可以通过Max-Age设置成时间段，也可以通过Expires设置成截止日期</li>
</ul>
<p>二、ETag：</p>
<ul>
<li>Etag是资源的标识，由服务器设置，浏览器每次请求，服务器都会生成资源的新的Etag值，并且读取请求报文中的if-none-match中保存的上一次资源的Etag值，将两次的值作比较</li>
<li>比较结果相同，返回304，浏览器就从缓存中读取资源</li>
<li>比较结果不同，就把服务器端的资源放到响应体里交给浏览器</li>
<li>Etag值通常是资源的md5值</li>
</ul>
<p>三、有什么不同：</p>
<ul>
<li>Cache-Control在有效期内，不发送http请求，ETag总是会发送http请求。</li>
</ul>
<p>##五、LocalStorage和Cookie的区别是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>浏览器访问服务器，cookie会被自动带上，localStorage不会。   </li>
<li>cookie的有效期是会话期，localStorage的有效期是永远，<br>我们可以通过Expires和Max-Age来改变cookie有效期，<br>我们可以通过清除缓存来清除localStorage。</li>
<li>cookie可以存的信息量大概是4kb左右，localStorage大概是10MB左右。</li>
</ol>
<p>##六、HTTP状态码知道哪些？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>200：请求被服务器成功处理</li>
<li>301：永久重定向</li>
<li>302：临时重定向</li>
<li>304：文件没有修改，可以直接使用缓存的文件</li>
<li>404：请求的资源不存在，比如输入了错误的URL</li>
<li>503：服务器出错，现在不能完成浏览器的请求，一段时间之后可能会恢复</li>
</ul>
<p>##七、（必考）GET和POST的区别是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、数据位置：Get的数据放在URL的查询参数里，POST的数据放在请求体里；<br>2、大小限制：GET是1024个字符，POST大概是10MB以内；<br>3、安全性：GET没有POST安全，其实两者都不安全；<br>4、缓存：GET可以被缓存，可以被收藏进书签，POST可以被缓存，不能被收藏进书签<br>5、作用：GET用来读数据，POST用来写数据，POST不幂等<br>  （幂等的意思是不管发送多少次请求，结果都一样）</p>
<p>##八、（必考）怎么跨域？CORS是什么？postMessage 是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>方法一：利用JSONP实现跨域：</li>
<li><p>方法二：CORS实现跨域：</p>
<p> 在请求首部字段中加入Origin: <a href="http://www.xx.com:8080">http://www.xx.com:8080</a><br> 在响应首部字段中加入Access-Control-Allow-Origin: <a href="http://www.xx.com:8080">http://www.xx.com:8080</a></p>
</li>
<li><p>方法三：postMessage：</p>
</li>
</ol>
<p>##九、表单加密有什么方式？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1.</p>
<ul>
<li>浏览器对传输的数据转成md5值，并且和服务器商量好，在该md5值中混入一些其他数字</li>
<li>服务器得到数据，去掉混入的数据后得到真正的md5值，将md5值转化成数据即可</li>
</ul>
<p>#JavaScript部分：</p>
<p>##一、JS 有哪些数据类型？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、七大数据类型：number、string、Boolean、undefined、null、object、symble；</p>
<p>2、object包括数组、函数、正则和日期等等。</p>
<p>##二、Promise怎么使用等等</p>
<blockquote>
<p>答案：</p>
</blockquote>
<pre><code>function myPromise(){
    return new Promise((resolve, reject)=&gt;{
        setTimeout(()=&gt;{
            resolve() 或者 reject()
        }, 3000)
    })
}

myPromise().then(成功函数1，失败函数1).then(成功函数2，失败函数2)

补充1：resolve函数其实就是成功函数1，reject函数其实就是失败函数1
补充2：成功函数1执行成功时，调用成功函数2，失败时调用失败函数2
补充3：失败函数1执行成功时，调用成功函数2，失败时调用失败函数2
</code></pre><blockquote>
<p>回答：<br>1、首先声明一个函数fn，在函数里面return一个promise对象，promise对象这样去定义，new Promise并且传入一个函数，该函数接收resolve和reject两个参数，然后执行一个异步操作，操作成功就调用resolve，失败就调用reject<br>2、then接收两个函数参数，第一个函数参数就是resolve，第二个函数参数就是reject。</p>
</blockquote>
<p>##三、（必考） AJAX 手写一下？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<pre><code>let xhr = new XMLHttpRequest()
xhr.open(&apos;POST&apos;,&apos;/ajax&apos;)                                  
xhr.onreadystatechange = ()=&gt;{               
    if(xhr.readyState===4){
        if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 || xhr.status===304){
            console.log(&apos;请求成功&apos;)
            console.log(xhr.responseText)
        }else if(xhr.status&gt;=400){
            console.log(&apos;请求失败&apos;)
        }                                
    }
}
xhr.send(&apos;a=1&amp;b=2&apos;)
</code></pre><blockquote>
<p>回答：<br>1、我们发送一个ajax时有四个步骤：<br>2、第一个步骤是创建一个XMLHttpRequest实例，let xxx = new XMLHttpRequest()<br>3、第二个步骤是监听ajax的发送状态，我们先跳过<br>4、第三个步骤是调用xxx的open方法，建立ajax请求，参数1是请求方式，通常为get或post，参数2是请求路径，/xxxx<br>5、第四个步骤是调用xxx的send方法，发送ajax请求，参数是请求体</p>
</blockquote>
<p>6、现在返过来说一下步骤2，怎么去监听整个状态，我们写xxx.onreadystatechange等于一个函数，在函数体里首先判断ajax的发送状态是不是完成，即xxx.readyState是否是4，在这个范围内，我们在判断响应状态是否成功，即xhr.status&gt;=200 &amp;&amp; xhr.status<300 || xhr.status===304就是成功，xhr.status>=400就是失败。响应成功的时候，xxx.responseText就是响应数据。</p>
<p>##四、（必考）闭包是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、闭包的定义：如果一个函数使用了它范围之外的变量，那么这个函数和这个变量就组成了闭包。  </p>
<p>2、闭包的目的：让一个局部变量拥有全局变量的随处可以访问到的优点而又不拥有全局变量污染全局环境的缺点。</p>
<p>3、闭包的使用方法有三个步骤：<br>第一步：先定义一个变量date，值为100，再定义一个函数inner，函数内操作变量date<br>第二步：将变量date和函数inner封装在一个自调用函数里，让函数inner作为自调用函数的返回值<br>第三步：将自调用函数赋值给变量xx，此时xx就保存着函数inner的地址<br>第四步：每次写xx()的时候，都可以拿到date的值了</p>
<pre><code>let xx = (()=&gt;{
    let date = 100
    return ()=&gt;{return date++}
})()
</code></pre><p>##五、（必考）什么是立即执行函数？使用立即执行函数的目的是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、立即执行函数也叫作“自调用函数”，目的是造出一个局部作用域，防止污染全局变量。</p>
<p>2、它的写法有很多种，原则是声明完一个函数后立即调用它，为了防止和前面的代码产生关联，需要在function关键字开头加上！或者；作为分割。</p>
<pre><code>/*ES5 中的写法：*/
方式1：!function(){}()
方式2：;(function(){}())
方式3：;(function(){})()

/*ES6 中的写法：*/
{
    const name = &apos;zhangzhiguo&apos;
    let age = 18
}
</code></pre><p>##六、（必考）这段代码里的 this 是什么？</p>
<blockquote>
<p>答案:</p>
</blockquote>
<p>1、口诀：有call看call，没call看点，没call没点就是window，在严格模式下，不是window而是undefined，此口诀对箭头函数、类以及事件绑定不适用。</p>
<p>2、举例：</p>
<ul>
<li>fn.call(): this指的是call方法的第一个参数，apply和bind方法也一样；</li>
<li>obj.fn(): this指的是obj对象</li>
<li><p>fn(): this指的是window，如果是严格模式下，就是undefined</p>
</li>
<li><p>()=&gt;{}: 箭头函数内外this一样</p>
</li>
<li>let xx = new ClassName(): this指的是类的实例xx</li>
<li><p>btn.addEventListener(‘click’, function(){}): this指的是事件源btn</p>
</li>
<li><p>myPromise.then(function(){}): this就是window</p>
</li>
<li>myPromise.then(()=&gt;{}): this就是resolve被调用时的环境里的this</li>
</ul>
<blockquote>
<p>回答：</p>
</blockquote>
<ul>
<li>现在有一个函数fn，当我写fn()时，this指的是window，在严格模式下，this指的是undefined</li>
<li>现在有一个函数fn，当我写fn.call()时，this指的是call的第一个参数，这一条也适用于apply和    bind方法</li>
<li>现在有一个对象obj，它有一个方法fn，当我写obj.fn()时，this指的是obj对象</li>
<li>()=&gt;{}: 箭头函数内外this一样</li>
<li>let xx = new ClassName(): this指的是类的实例xx</li>
<li>btn.addEventListener(‘click’, function(){}): this指的是事件源btn</li>
</ul>
<p>##七、如何实现深拷贝？</p>
<blockquote>
<p>答案:</p>
</blockquote>
<p>1、方法一、利用JSON对象的stringfy和parse方法，<br>  缺点: 不支持函数、引用、undefined、RegExp、Date</p>
<pre><code>var a = {...}
var b = JSON.parse( JSON.stringify(a) )
</code></pre><p>2、方法二、递归方法</p>
<blockquote>
<p>回答：<br>方法一、JSON.parse括号，传入JSON.stringify括号，传入想要深拷贝的对象即可，</p>
</blockquote>
<p>##八、如何实现数组去重？</p>
<blockquote>
<p>答案:</p>
</blockquote>
<p>1、借助对象属性名</p>
<pre><code>let arr = [-2,&apos;2&apos;, 2 ,5,8,8,1,9,9,3,3]
function filterArray(arr){
    let obj = {}
    let newArr = []
    arr.map((item)=&gt;{
        if(obj[item] !== item){
            obj[item]=item
               newArr.push(item)
        }
    })
    return newArr
}
</code></pre><p>2、利用数组的indexof方法</p>
<pre><code>function filterArray(arr){
    let newArr = []
    arr.map((item)=&gt;{
        newArr.indexOf(item) === -1 &amp;&amp; newArr.push(item)
    })
    return newArr
}
</code></pre><blockquote>
<p>回答：</p>
</blockquote>
<ul>
<li>首先我定义一个新数组，然后遍历想要去重的数组，每次遍历的时候都做一个判断，看元素是否在新的数组里，在的话什么都不做，不在的话就把元素push到新数组里</li>
<li>当遍历完的时候，新数组就是去重后的数组了</li>
<li>我是怎么判断元素是否在新数组中的呢？我是调用新数组的indexOf方法并传入元素，如果结果为-1就表示元素不在新数组里，此时就把元素push到新数组里即可</li>
</ul>
<p>3、Set去重</p>
<pre><code>Array.from(new Set(arr))
</code></pre><p>##九、如何用正则实现 string.trim()？</p>
<blockquote>
<p>回答：</p>
</blockquote>
<pre><code>string.replace(/^\s+|\s+$/g, &apos;&apos;)
补充：^平方号是开头，\s是空格，+是多个，$是结尾，g匹配多个
</code></pre><p>##十、JS 原型是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、首先声明一个空数组a，此时空数组只有一个值为0的length属性<br>2、为什么可以调用a.push()方法呢？<br>3、原来a有一个隐藏的<em>proto</em>属性，指向a的构造函数Array的prototype属性，<br>4、Array.prototype就是我们所说的原型对象<br>5、通过Array构造函数构造出的实例对象，都从原型上继承属性和方法</p>
<p>构造函数的prototype属性指向一个对象，该对象内保存着所有通过构造函数创建的实例共享的属性和方法，该对象就是原型对象，简称原型，原型有个constructor属性，指向构造函数。</p>
<p>##十一、ES6中的class了解吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、类是ES6中的一个特殊函数，作用和ES5中的构造函数是一样的，它返回一个对象<br>2、我们这样去创建，class关键字后面接一个类名，然后花括号里写constructor函数，在该函数内部定义自有属性，在该函数外部定义公有属性，使用static关键字还可以定义静态属性<br>3、我们这样去使用，new关键字后面接类的名字并传入参数，它会自动调用constructor函数并返回一个对象，我们称该对象为类的实例<br>4、因为类的实例拥有类中的所有属性和方法，实现了代码复用的目的。</p>
<p>5、自有属性的值是根据实例的不同而不同的，所以写在constructor函数里，方便的使用constructor函数接收到的实例参数。<br>公有属性的值不会根据实例的不同而不同，所以写在constructor函数外面，不需要constructor函数接收到的实例参数。<br>静态属性是类声明内部用到的属性，而不会继承给实例对象。</p>
<p>##十二、JS 如何实现继承？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、ES5中实现继承，</p>
<pre><code>function Country(options){
    this.countryName = &apos;中国&apos;
}
Country.prototype.sayCountryName = function(){
    console.log(this.countryName)
}

function Capital(options){
    Contry.apply(this, options)
    this.capitalName = &apos;北京&apos;
}
Capital.prototype = Object.create(Country.prototype)
Capital.prototype.sayCapitalName = function(){
    console.log(this.capitalName)
}

let obj = new Capital()
obj.sayCapitalName()
obj.sayCountryName()
</code></pre><p>2、ES6中实现继承：</p>
<pre><code>class Country{
    constructor(){
        this.countryName = &apos;中国&apos;
    }
    sayCountryName(){
        console.log(this.countryName)
    }
}

class Capital extends Contry{
    constructor(props){
        super(props)
        this.capitalName = &apos;北京&apos;
    }
    sayCapitalName{
        console.log(this.capitalName)
    }
}

let obj = new Capital()
obj.sayCapitalName()
obj.sayCountryName()
</code></pre><blockquote>
<p>回答： </p>
</blockquote>
<p>1、ES5中是函数式继承，ES6中是类继承</p>
<p>2、函数式继承：假设函数A想要继承函数B，需要做两件事：<br>首先在函数A里用apply方法调用函数B，第一个参数是this，第二个参数函数A接收到的实参；<br>然后在函数A外面调用Object对象的create方法，并传入B.prototype作为参数值，将执行结果赋值给A.prototype。</p>
<p>3、类继承：假设类A想要继承类B，需要做两件事：<br>首先用class关键字声明类的时候，加上extends B，<br>然后在类A里constructor函数里调用super并传入constructor函数接收到的参数</p>
<p>##十五、== 相关题目直接反着答（放弃）</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>##十六、DOM 事件模型是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、原生JS有两种事件模型，一个是DOM0级事件模型，另一个是DOM2级事件模型，DOM0级有事件覆盖的问题，我们一般不用<br>2、DOM2级事件模型我准备从三方面阐述，<br>一是事件构成：事件源、事件类型、事件处理函数<br>二是添加和移除事件的方法：addEventListener()、removeEventListener()<br>三是事件流：事件流有两个阶段，分别是捕获阶段和冒泡阶段<br>    捕获阶段：从最不具体的元素到最具体的元素<br>    冒泡阶段：从最具体的元素到最不具体的元素<br>四是事件处理函数的执行顺序：先执行捕获阶段的，在执行冒泡阶段的，<br>    这里有个特例，就是绑定事件和触发事件的是同一个对象，那么捕获阶段和冒泡阶段谁写在前面谁就先执行。</p>
<p>##十七、事件委托是什么？有什么好处？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、事件委托是利用了事件冒泡解决了“事件处理程序过多”的问题，目的在于提高网站的性能。</p>
<p>2、比如我们想在一个ul的所有li子元素上添加click点击事件，我们只需要在ul元素上添加点击事件就可以了。</p>
<p>3、我们还可以监听暂时不存在的li元素，函数是这样的：</p>
<pre><code>function MyAddEventListener(element, eleType, selector, fn){
    element.addEventListener(eleType, (ev)=&gt;{
        let target = ev.target
        while(target !== element){
            if(target.tagName.toLowerCase() === selector){
                fn.call(null, ev)
                break
            }
            target = target.parentNode
        }
    })
}
</code></pre><blockquote>
<p>回答：<br>1、事件委托是利用了事件冒泡来解决“事件处理程序过多”的问题，目的在于提高网站的性能。<br>2、假设ul元素下边有3个li元素，如果想在li元素上添加click点击事件，我们只需要在ul元素上添加点击事件就可以了。<br>3、假设ul元素下边有3个li元素，每个li元素下边又有一个div元素，<br>我们先写一个循环，如果点击的元素不是ul元素，就进入循环体，<br>如果点击的元素是li元素，就执行事件处理函数，跳出循环体；<br>如果点击的元素不是li元素，就找到点击的元素的父元素，进入循环判断：是否是ul元素。</p>
</blockquote>
<p>##十八、移动端的触摸事件了解吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>touchmove、touchstart、touchend</li>
<li>判断滑动方向：</li>
</ol>
<p>##十九、async/await 语法了解吗？目的是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、首先声明一个函数，在function关键字前面加上async关键字<br>2、然后在函数体内异步任务之前加上await关键字<br>3、浏览器执行的时候，会等异步任务结束后才执行后面的任务<br>4、这就达到了我们“先执行异步任务，拿到结果交给同步任务去操作的目的”<br>5、并且，代码整体上看，更像是在书写同步代码，从上往下依次执行，没有跳跃</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*async函数*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入fn函数'</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'时间到了'</span>)</span><br><span class="line">            resolve(<span class="string">'这里异步返回的结果'</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'fn函数的结果'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*async函数的调用*/</span></span><br><span class="line">fn().then(<span class="function">(<span class="params">xx</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xx)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn函数之后的同步函数'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果*/</span></span><br><span class="line">输出：进入fn函数</span><br><span class="line">输出：fn函数之后的同步函数</span><br><span class="line">输出：时间到了</span><br><span class="line">输出：这里异步返回的结果</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*async函数*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入fn函数'</span>)</span><br><span class="line">       setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'时间到了'</span>)</span><br><span class="line">       &#125;, <span class="number">2000</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'fn函数的结果'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*async函数的调用*/</span></span><br><span class="line">fn().then(<span class="function">(<span class="params">xx</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(xx)</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn函数之后的同步函数'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果*/</span></span><br><span class="line">输出：进入fn函数</span><br><span class="line">输出：fn函数之后的同步函数</span><br><span class="line">输出：fn函数的结果</span><br><span class="line">输出：时间到了</span><br></pre></td></tr></table></figure>
<p>##二十、构造函数？原型？原型链？</p>
<ol>
<li>构造函数：</li>
</ol>
<ul>
<li>构造函数是特殊的函数，它返回一个对象。</li>
<li>JS引擎会帮我们创建一个this对象，把所有属性和方法绑定到this上，最后将this返回</li>
<li>JS引擎还帮我们绑定原型对象，所有new出来的实例对象都从原型对象上继承属性和方法</li>
<li>我们通过new来调用构造函数</li>
</ul>
<ol start="2">
<li>原型：</li>
</ol>
<ul>
<li>构造函数的prototype属性指向一个对象，</li>
<li>该对象保存着所有构造函数创建出来的实例对象共享的属性和方法，</li>
<li><p>该对象就是原型对象，它有一个默认的constructor属性，指向构造函数。</p>
</li>
<li><p>构造函数的prototype属性指向原型，原型的constructor属性指向构造函数</p>
</li>
<li>实例对象的<em>proto</em>属性指向原型，实例对象的constructor属性指向构造函数</li>
</ul>
<ol start="3">
<li>原型链：</li>
</ol>
<ul>
<li>原型链的数据结构是树</li>
<li>属性查找时，先在对象上找，找到结束，找不到就去原型上找</li>
<li>原型上找到了就结束，找不到就去原型的原型上找</li>
<li>一直到Object.prototype对象为止，找到结束，找不到就返回undefined</li>
</ul>
<p>##二十一、包装对象</p>
<p>把数字基本类型值当成对象去操作时，JS引擎自动帮我们创建了一个包装对象，操作完毕JS引擎会自动帮我们销毁该包装对象，并且不影响原来的值。<br>包装对象三步走：创建对象、操作对象、销毁对象</p>
<p>#CSS部分：</p>
<p>##一、（必考）问题：说说盒模型？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、盒模型有两种，content-box和border-box，通过box-sizing属性设置。</p>
<p>2、content-box盒模型直观上理解就是“向外扩”，<br>假设现有有一个块级元素div，当我们设置了width后，在设置内边距时，盒子往外扩一点，在设置边框时，盒子又会往外扩一点，那么最终盒子的总尺寸就是width、padding、border三个值的总和，高度也是同样的道理。<br>假设现在有一个行内元素span，如果我们设置它的宽度和高度，是不起作用的，它的左右内边距、边框和外边距起作用，它的上下内边距、边框和外边距在空间上不起作用，在层叠上起作用。<br>假设现在有一个行内块元素div，它的显示效果和div是一样的。</p>
<p>3、border-box盒模型直观上理解就是“向里缩”，大致上和content-box一样，<br>假设现有有一个块级元素div，当我们设置了width后，在设置内边距时，盒子往里缩一点，在设置边框时，盒子又会往里缩一点，那么最终盒子的的总尺寸就是width值，高度也是同样的道理。  </p>
<p>##二、问题：css reset 和 normalize.css 有什么区别？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、我们写的HTML标签在浏览器中都有默认的样式，但是浏览器不同，默认样式也是不同的，这让我们很头疼，于是就出现了两种解决方案，一个是css reset样式重置，令一个是normalize.css样式正常化。</p>
<p>2、css rese是写一套样式将浏览器的默认样式全部替换掉，normalize.css是保留有价值的默认值，只修改会导致浏览器兼容问题的样式。</p>
<p>3、normalize.css是css reset的替代方案，功能更强大，他能同时修复桌面端和移动端浏览器的bug。</p>
<p>##三、问题：（必考）如何居中？</p>
<blockquote>
<p>逻辑： </p>
</blockquote>
<ul>
<li>水平：display、text-align、左右padding、绝对定位、margin为auto</li>
<li>垂直：display、line-height、上下padding、绝对定位、真table、假table</li>
</ul>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、这个问题分为水平居中和垂直居中，<br>想要水平居中时： </p>
<ul>
<li>最简单的方式就是在父元素上设置display为flex，justify-content为center即可。</li>
<li>当子元素是行内或行内块元素时，我们在父元素上设置text-align样式值为center即可。  </li>
<li>当子元素是块级元素且定宽时，我们在子元素上设置左右margin为auto即可。</li>
</ul>
<p>2、想要垂直居中时，有六种方法：</p>
<ul>
<li>最简单的方式就是在父元素上设置display为flex，alin-items为center即可。</li>
<li>如果父元素定高，我们还可以设父元素的上下padding值为父元素高度减去子元素的高度的一半即可。</li>
<li>当子元素是内联元素时，特指文字，我们在父元素上设置line-height，那么文字就会自动垂直居中</li>
<li>当子元素是块级元素时，可以让子元素绝对定位，然后设置top为50%，tranform的translate在垂直方向上负50%即可；</li>
</ul>
<p>##四、问题：选择器优先级如何确定？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、考虑权重：有!import &gt; 没有!import</p>
<p>2、考虑位置和引入方式：内联样式 &gt; 内部样式块 &gt; 外部样式表；后面出现 &gt; 前面出现</p>
<p>3、考虑特殊性：高特殊性 &gt; 低特殊性 &gt; 没有特殊性</p>
<p>特殊性数值为：<br>内联样式为1000；id选择器为0100；类选择器，伪类选择器，属性选择器为0010；通配符选择器为0000；特殊性为0000的通配符比没有特殊性的默认样式优先级高。</p>
<p>##五、问题：BFC是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、BFC是格式化上下文，我准备从实际开发中遇到的4个bug来阐述这个问题<br>bug1：有两个div元素，是兄弟关系，都设置了外边距，此时外边距是两者之和吗？当然不是，因为发生了外边距合并。<br>bug2：有两个div元素，是父子关系，如果父元素没有设置border或者padding，子元素设置了上下margin，最终的显示效果是子元素margin超出父元素区域，使父元素移动。<br>bug3：ul中li元素全部浮动后，ul元素会出现塌陷，意思就是高度没有了。<br>bug4：如果一个元素浮动脱离了文档流，下面的元素就是跑上去，但是会被浮动的元素遮盖住。</p>
<p>2、这些问题都可以通过创建BFC解决，创建BFC的常见方式有五种：<br>overflow：hidden、display：flow-root或者inline-block、使元素浮动或绝对定位。</p>
<p>##六、问题：如何清除浮动？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、常见做法是：overflow: hidden，但是我不这么做<br>2、在父元素上增加一个伪类选择器，设置三个属性，</p>
<pre><code>.clearfix::after{content:&apos;&apos;; display: block; clear: both}
</code></pre><p>如果要兼容IE的话，.clearfix::after{content:’’; display: block; clear: both； zoom: 1}</p>
<p>##七、问题：CSS3动画了解吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、<br>    /<em>除两个时间外，顺序可以打乱</em>/<br>    transtion: &lt;参与属性&gt; &lt;持续时间&gt; &lt;动画节奏&gt; &lt;延迟时间&gt;        </p>
<pre><code>transform: translate(100px, 500px);    //平移
transform: scale(0.5, 2);        //缩放
transform: rotate(90deg);        //旋转
transform: skew(30deg, 60deg);        //扭曲
</code></pre><p>2、<br>    /<em>除两个时间外，顺序可以打乱</em>/<br>    animation: &lt;动画名称&gt; &lt;持续时间&gt; &lt;动画节奏&gt; &lt;延迟时间&gt; &lt;播放次数&gt; &lt;逆向播放&gt;</p>
<pre><code>@keyframes &lt;动画名称&gt;
{
    0% { opacity: 0 }
    100%{ opacity: 1 }
}
</code></pre><p>##一、问题：（必考） 你是如何理解 HTML 语义化的？</p>
<blockquote>
<p>文章：<a href="https://www.cnblogs.com/fliu/articles/5244866.html">https://www.cnblogs.com/fliu/articles/5244866.html</a></p>
</blockquote>
<blockquote>
<p>思路：什么是HTML语义化、原来做法及缺点、现在做法及优点、</p>
</blockquote>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、什么类型的内容就用什么标签去包裹，不能胡乱使用！</p>
<p>2、以前的做法是：内容使用无语义化的div和span标签，主要缺点有：</p>
<ul>
<li>代码不清晰，不利于开发者阅读</li>
<li>不利于SEO搜索引擎优化和爬虫抓取信息</li>
</ul>
<p>3、现在的做法是：表头用header、主体用main、表尾用footer、表头中导航条用nav、区块儿用section（区块儿的意思是页面中的分组或者文章中的段落）、侧边栏用aside、表尾联系方式用address、文章用article</p>
<p>##二、问题：meta viewport 是做什么用的，怎么写？</p>
<blockquote>
<p>思路：痛点、写法、解决痛点的方法</p>
</blockquote>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、meta:vp是防止手机网页自动缩放的，写法是：</p>
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

<p>2、为什么要写这句话呢？因为先有的大屏幕的电脑，后有小屏幕的手机，手机厂商为了让网页很好展示，就让网页整体缩小。但是会出现一个问题，就是内容太小了，想要看清楚，还要用两个手指去放大它，这当然不是我们想要的，于是我们加上meta:vp，不让它自动缩小。</p>
<p>##三、问题：canvas 元素是干什么的？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、canvas是HTML5新增的元素，目的在于通过JavaScript中的脚本来绘制图形。</p>
<p>2、先在HTML文件中写入canvas标签，然后在JS文件中通过document.getElementById等方法将其转化成对象，然后调用该对象的getContext(‘2d’)方法，得到绘画上下文，然后根据创建的形状不同，调用不同的API即可。</p>
<p>3、注意点1：width和height属性应该写在canvas标签上而不是css样式里，因为width默认300px和height默认150px，样式中的width和height是根据这两个值做缩放而不是覆盖，这就导致画布中的元素也会缩放而出现失真。<br>注意点2：描边和填充的顺序问题，描边在前填充在后，尺寸是描边的尺寸；描边在后填充在前，尺寸是描边加填充的尺寸之和。</p>
</script></li></ul>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/27/resume/" data-id="cjoyikbdx000sekqrxlf6s4ju" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/11/23/数据结构和算法/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据结构和算法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/27/resume/">resume</a>
          </li>
        
          <li>
            <a href="/2018/11/23/数据结构和算法/">数据结构和算法</a>
          </li>
        
          <li>
            <a href="/2018/11/23/JS-Canvas/">JS-Canvas</a>
          </li>
        
          <li>
            <a href="/2018/11/23/网络安全/">网络安全</a>
          </li>
        
          <li>
            <a href="/2018/11/23/前后端交互/">前后端交互</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 张治国<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>