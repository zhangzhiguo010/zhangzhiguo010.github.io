<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>张治国的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="张治国的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="张治国的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张治国的博客">
  
    <link rel="alternate" href="/atom.xml" title="张治国的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张治国的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-resume" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/25/resume/" class="article-date">
  <time datetime="2018-11-24T16:14:50.000Z" itemprop="datePublished">2018-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/25/resume/">resume</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#2018.11月准备面试：</p>
<p>##面试经验：</p>
<p>##十六、sort函数使用什么算法？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_Sort = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn = fn || <span class="function"><span class="keyword">function</span> <span class="title">ff</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>; j&lt;<span class="keyword">this</span>.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn.call(<span class="literal">null</span>, <span class="keyword">this</span>[j], <span class="keyword">this</span>[i])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                [<span class="keyword">this</span>[i], <span class="keyword">this</span>[j]] = [<span class="keyword">this</span>[j], <span class="keyword">this</span>[i]]</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>冒泡排序和插入排序的混合</li>
</ul>
<p>##十五、HTTP和HTTPS的区别？</p>
<ul>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>
<li></li>
</ul>
<p>##十四、web性能优化<br><a href="https://github.com/creeperyang/blog/issues/1" target="_blank" rel="noopener">雅虎前端优化35条规则翻译</a></p>
<ol>
<li>浏览器缓存： 使用cache-control max-age=1</li>
<li>使用CDN加速，CDN就是内容分发</li>
<li><p>使用gzip报文压缩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*客户端*/</span></span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"><span class="comment">/*服务器*/</span></span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用图片压缩，PS</p>
</li>
<li>使用webpack进行打包，减少文件请求数量</li>
<li>懒加载，在可视区域内才加载</li>
</ol>
<p>##十三、在html里控制缓存？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Expires"</span> content=<span class="string">"0"</span> /&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Cache-control"</span> content=<span class="string">"no-cache"</span> /&gt;</span><br><span class="line"></span><br><span class="line">Cache-control时content属性值：</span><br><span class="line">no-cache，浏览器和缓存服务器都不应该缓存页面信息；</span><br><span class="line">Expires，GMT格式，指浏览器或缓存服务器在截止日期后从真正的服务器中获取新的页面信息；</span><br></pre></td></tr></table></figure></p>
<p>##十二、数组有哪些方法？</p>
<p>##十一、什么是mixin？</p>
<ul>
<li>mixin是”混入“、“混合”，将一个对象的属性复制给另一个对象。</li>
<li>功能上类似于Object.assign({}, obj1, obj2)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mixin = <span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> b)&#123;</span><br><span class="line">		a[key] = b[key]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##十、什么是继承？</p>
<ul>
<li>继承使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码</li>
<li>JS里有ES5的函数式继承和ES6的类继承</li>
</ul>
<p>##九、prototype属性的作用：</p>
<ul>
<li>存放共有属性的地址</li>
</ul>
<p>##八、什么是柯里化？</p>
<ul>
<li>用单参数函数模拟多参数函数</li>
<li>调用某函数并传入部分参数，让它返回一个函数去接受剩下的参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*普通函数*/</span></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="function">(<span class="params">x, y</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"><span class="comment">/*柯里化函数*/</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">y</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##七、什么是高阶函数？</p>
<ul>
<li>输入一个或多个函数</li>
<li>输出一个函数</li>
<li>满足上面条件之一就是高阶函数，但通常同时满足两个</li>
</ul>
<p>补充：</p>
<ol>
<li>什么是高阶组件？</li>
</ol>
<ul>
<li>接收一个组件，返回一个新的组件，典型的就是react-redux库中引入的connect函数</li>
</ul>
<p>##六、什么是纯函数？</p>
<ul>
<li>函数的返回结果只依赖于它的参数</li>
<li>函数执行过程里面没有副作用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*纯函数*/</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">x, y</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*不是纯的*/</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">x, a</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+a&#125;		<span class="comment">// a值的改变，会影响函数输出结果</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*纯函数*/</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">obj, y</span>)=&gt;</span>&#123;<span class="keyword">return</span> obj.x + y&#125;</span><br><span class="line"><span class="keyword">const</span> object = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">fn(object, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*不是纯的*/</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">obj, y</span>)=&gt;</span>&#123;</span><br><span class="line">	obj.x = <span class="number">10</span>					<span class="comment">// 修改了外部传进来的变量，而不只是单纯的使用</span></span><br><span class="line">	<span class="keyword">return</span> obj.x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> object = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">fn(object, y)</span><br></pre></td></tr></table></figure>
<p>##五、环信？</p>
<p>环信API用的是XMPP协议，XMPP是一种类似于HTTP协议的数据传输协议，传输的数据都是XML格式的。</p>
<p>工作原理：</p>
<ol>
<li>客户端1连接到服务器</li>
<li>服务器对其认证</li>
<li>客户端1指定客户端2的地址，让服务器去查找</li>
<li>服务器查找、链接并进行相互认证，成功后</li>
<li>客户端1和客户端2就可以进行交互啦</li>
</ol>
<p>特点：</p>
<ul>
<li>XMPP允许客户端、服务器和网关，三者之间消息互通。</li>
<li>客户端：发送和接收消息的设备</li>
<li>服务器：实现了客户端的信息记录、信息路由、链接管理功能</li>
<li>网关：实现了不同的通信系统间交换信息，实现该功能的服务器在XMPP架构里被称作网关</li>
</ul>
<p>##四、canvas基本用法：<br>1、准备工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*html文件中，创建canvas元素*/</span></span><br><span class="line">&lt;canvas width=<span class="string">'300'</span> height=<span class="string">'150'</span> id=<span class="string">'canvas'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span>  <span class="comment">// 注意width和height</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*js文件中，将该元素转化成对象*/</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#canvas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用getContext()方法，得到绘图上下文*/</span></span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>)</span><br></pre></td></tr></table></figure>
<p>2、矩形</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的矩形*/</span></span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.fillRect(x, y, width, height)</span><br><span class="line"><span class="comment">// x、y: 分别是起点X轴和y轴坐标</span></span><br><span class="line"><span class="comment">// width、heigth: 分别是矩形的宽度和高度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的矩形*/</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeRect(x, y, width, height)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*清除矩形部分内容*/</span></span><br><span class="line">context.clearRect(x, y, width, height)</span><br></pre></td></tr></table></figure>
<p>3、三角形</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的三角形*/</span></span><br><span class="line">context.beginPath()			<span class="comment">// 开始画画</span></span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.moveTo(x, y)		<span class="comment">// 起始点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.fill()				<span class="comment">// 填充</span></span><br><span class="line">context.closePath()			<span class="comment">// 结束画画</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的三角形*/</span></span><br><span class="line">context.beginPath()			<span class="comment">// 开始画画</span></span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.moveTo(x, y)		<span class="comment">// 起始点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 想要闭合，x和y是起始点；不想闭合，不用此lineTo()</span></span><br><span class="line">context.stroke()			<span class="comment">// 描边</span></span><br><span class="line">context.closePath()			<span class="comment">// 结束画画</span></span><br></pre></td></tr></table></figure>
<p>4、圆形/圆弧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的圆形*/</span></span><br><span class="line">context.beginPath()</span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">context.fill()</span><br><span class="line">context.closePath()</span><br><span class="line"><span class="comment">// x、y: 圆心x轴和y轴坐标</span></span><br><span class="line"><span class="comment">// radius: 半径</span></span><br><span class="line"><span class="comment">// startAngle、endAngle: 圆弧的起点和终点，Math.PI是π</span></span><br><span class="line"><span class="comment">// anticlockwise：true为顺时针、false为逆时针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的圆形*/</span></span><br><span class="line">context.beginPath()</span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">context.stroke()</span><br><span class="line">context.closePath()</span><br></pre></td></tr></table></figure>
<p>##三、== 和 === 间的区别是什么？<br>1、 </p>
<ul>
<li>==： 相等运算符，类型相同直接比较，比较的是数值，类型不同先转换后比较</li>
<li>===：全等运算符，类型相同直接比较，比较的是地址，类型不同直接false</li>
</ul>
<p>2、相等运算符的转换规则：</p>
<p>（1）基本类型相互间比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*null和undefined不做类型转换，但null和undefined相等；*/</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="number">1</span>				<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="string">'1'</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="literal">true</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="literal">false</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>				<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数字和字符串，字符串被Number()函数转成了数字*/</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'1'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'01'</span>			<span class="comment">// 正确		1 == 01</span></span><br><span class="line"><span class="comment">/*数字和布尔值，布尔值被Number()函数转成了数字*/</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'false'</span>		<span class="comment">// 正确		0 == 0</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'true'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串和布尔值，字符串和布尔值都被Number()函数转成了数字*/</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'1'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'0'</span>		<span class="comment">// 正确		0 == 0</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'123'</span>		<span class="comment">// 错误		1 == 123</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'123'</span>		<span class="comment">// 错误		0 == 123</span></span><br></pre></td></tr></table></figure>
<p>（2）引用类型间相互比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*比较的是地址，地址相同的情况*/</span></span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">age</span>: <span class="number">28</span>&#125;	<span class="comment">//假 地址：100</span></span><br><span class="line"><span class="keyword">let</span> d = c			<span class="comment">//假 地址：100</span></span><br><span class="line">c == d				<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*比较的是地址，地址不同的情况*/</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;	<span class="comment">//假 地址：101</span></span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;	<span class="comment">//假 地址：102</span></span><br><span class="line">a == b				<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>（3）基本类型和引用类型比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对象和数字：对象转成数字*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="number">0</span>			<span class="comment">// 正确		0 == 0</span></span><br><span class="line">[<span class="number">123</span>] == <span class="number">123</span>		<span class="comment">// 正确		123 == 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象和字符串：对象转成字符串*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="string">'0'</span>			<span class="comment">// 正确		'0' == '0'</span></span><br><span class="line">[<span class="number">123</span>] == <span class="string">'123'</span>		<span class="comment">// 正确		'123' == '123'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象和布尔值，对象和布尔值都转成了数字*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="literal">true</span>		<span class="comment">// 错误		0 == 1</span></span><br><span class="line">[<span class="number">0</span>] == <span class="literal">false</span>	<span class="comment">// 正确		0 == 0</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">true</span>		<span class="comment">// 正确		1 == 1</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">false</span>	<span class="comment">// 错误		1 == 1</span></span><br><span class="line">[<span class="number">123</span>] == <span class="literal">true</span>	<span class="comment">// 错误		123 == 1</span></span><br></pre></td></tr></table></figure>
<p>3、(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 可能为 true 吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*a会自动调用toString()方法，该方法被我重写了*/</span></span><br><span class="line">a = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  toString()&#123;</span><br><span class="line">    a.value += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a.value </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#二、em和rem的区别：<br>em: 当前元素的font-size值，font-size值是自己设定的或者从父元素继承的。<br>rem: 根元素的font-size值，根元素是html元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心：屏幕宽度 == <span class="number">10</span>rem</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">`&lt;style&gt;html&#123; font-size: <span class="subst">$&#123;<span class="built_in">window</span>.innerWidth<span class="regexp">/10&#125;px &#125;&lt;/</span>style&gt;<span class="string">`)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        （除以10而不是100是因为：方便计算、浏览器font-size最小是12px）</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">实战：屏幕宽度为500px，元素1宽度为100px，元素2宽度为300px，如何用rem表示？</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">          元素1：px单位：100/500 * 500px     rem单位：100/500 * 10rem</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">          元素2：px单位：300/500 * 500px     rem单位：300/500 * 10rem</span></span></span></span><br></pre></td></tr></table></figure>
<p>##一、opacity 和 rgba()有什么不同？<br>opacity：影响当前元素和其后代元素的透明度。<br>rgba(): 影响当前元素的透明度，不影响后代元素。<br>filter: opacity(): 和opacity一样</p>
<p>filter滤镜属性：高斯模糊、亮度、对比度、饱和度、透明度、灰度、颜色反转、阴影<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter: blur()  <span class="comment">//高斯模糊，默认是0，值越大越模糊</span></span><br><span class="line">filter: brightness()  <span class="comment">//明暗度，默认是100%，小于100%则暗，大于100%则亮</span></span><br><span class="line">filter: contrast()	<span class="comment">//对比度，默认是1，小于100%对比强烈，大于100%对比更低</span></span><br></pre></td></tr></table></figure></p>
<p>#React框架：</p>
<p>##一、React的基本组成单位是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>基本组成单位是元素，元素可以是HTML的原生的标签，也可以是自定义组件</li>
</ol>
<ul>
<li>原生的标签：const element = <div>哈哈</div></li>
<li>自定义组件：const element = <welcome name="zhang"></welcome></li>
</ul>
<p>##二、JSX是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>JSX是JavaScript和XML混合后的新语法，看着像html，实际上是js。</li>
<li>JSX可以防止XSS攻击，原因是在渲染之前都被转化成了字符串。</li>
<li>Babel编译JSX的时候实际上是在调用React.createElement()函数，该函数的三个参数分别是标签名、属性对象和标签内容</li>
</ul>
<p>##三、React如何渲染元素：</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>首先用JSX创建一个虚拟的dom元素</li>
<li>然后调用ReactDOM的render方法，将虚拟的dom插入到页面里</li>
</ul>
<p>##四、React组件的定义？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>React组件本质就是函数，接收输入值，返回React元素；</li>
<li>在ES5中是函数式组件，在ES6中是的类组件</li>
</ul>
<p>##五、React组件的生命周期？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>生命周期分为三个阶段</li>
<li>装载阶段有：constructor、componentWillMount、componentDidMount</li>
<li>更新阶段有：componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate</li>
<li>卸载阶段有：componentWillUnmount</li>
</ul>
<p>常用的声明周期是？</p>
<ul>
<li>componentWillMount：发送ajax请求，向后端要数据；  <pre><code>如果想在标签上直接绑定事件（DOM0），就在这里定义事件处理函数
</code></pre></li>
<li>componentDidMount：通过addEventListener方式绑定事件放在这个函数里（DOM2）</li>
<li>shouldComponentUpdate：决定是否要更新，来提高组件性能，返回true就向下执行，否则不执行</li>
<li>componentWillUnmount：在这里取消定时器，取消事件监听，防止内存泄漏</li>
</ul>
<p>##六、React单向数据流？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>父组件通过props向子组件传递数据，这个props原则上是只读的，子组件不能更改；</li>
</ul>
<p>##七、虚拟DOM？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>浏览器首次渲染，会将html转化成dom树，html中的标签和dom树中的节点一一对应。</li>
<li>浏览器更改页面，如果直接操作dom树上的节点，会引起浏览器对网页进行重新布局，重新绘制，性能很差。</li>
<li>于是我们在JavaScript空间里创建虚拟dom树，组件渲染的时候，会将这次的虚拟dom树和上一次渲染的虚拟dom树进行对比，找到被修改的地方，然后通过ReactDOM.render方法去修改浏览器空间里的真实dom树的相应位置。</li>
</ul>
<p>##八、你了解redux吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li><p>Redux帮助React做数据管理，组件自己用到的数据就放到自己的constructor函数里state对象中，组件之间共享的数据交给redux</p>
</li>
<li><p>组件怎么从store中得到数据呢？调用store的getState方法就可以了。</p>
</li>
<li><p>组件怎么修改store中的数据呢？调用store的dispatch方法并传入action作为参数就可以了。</p>
</li>
<li><p>store是怎么来的呢？store是导入redux文件后获得createStore函数，调用该函数传入reducer作为参数就得到了store</p>
</li>
<li><p>reducer是什么呢？它是一个函数，接收初始数据和action作为参数，根据action的类型，更改数据。store的数据树就是由reducer中的初始数据共同组成了。</p>
</li>
<li><p>action是什么呢？它是一个带着类型和数据的对象。</p>
</li>
<li><p>dispatch做了什么呢？它做了两件事，一个是调用reducer函数并传入action参数，修改store的状态树；另一个就是调用subscribe传过来的监听函数。</p>
</li>
<li><p>subscribe函数是store对象的方法，专门提供reducer函数修改完数据以后要做的任务，通常是调用store的getState方法得到最新的数据然后渲染页面。</p>
</li>
</ul>
<p>##九、你了解react-redux吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>redux可以用于任何框架，而react-redux是专门帮助react做数据管理的</li>
<li>react-redux经常被用到的是Provider组件和connect函数，</li>
<li><p>假设组件A向子组件B传递数据，  </p>
<p>我认为Provider组件是组件A的助手，帮助发送数据的。<br>用法是：将Provider组件作为根组件，并传递store属性给Provider组件。  </p>
<p>我认为connect函数是组件B的助手，帮助接收或修改数据。<br>用法是：在声明组件B的地方用修饰符的方式调用connect函数，传入两个参数，第一个参数使组件能够接收到store的数据。第二个参数使组件获得store的dispatch方法，也就是修改store数据能力。 </p>
</li>
</ul>
<p>##十、hashHistory和browserHistory的区别？</p>
<ol>
<li>url地址不同： </li>
</ol>
<ul>
<li>使用hashHistory,浏览器的url是这样的：/#/user/liuna?_k=adseis</li>
<li>使用browserHistory,浏览器的url是这样的：/user/liuna</li>
</ul>
<ol start="2">
<li>是否发送请求：</li>
</ol>
<ul>
<li>使用hashHistory，不发送请求</li>
<li>使用browserHistory，向服务器发送请求，所以需要服务器的支持</li>
</ul>
<ol start="3">
<li>404错误：</li>
</ol>
<ul>
<li>用户手动刷新页面，hashHistory不会报404错误，browserHistory会报404错误</li>
<li>browserHistory需要后台服务器做路由配置，如果没做的话，用户手动刷新就会报错。</li>
<li></li>
</ul>
<p>#Webpack工程化部分：</p>
<p>##一、转义出的文件过大怎么办？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li><p>使用代码分离技术，具体有两种方法，一种是入口起点，一种是按需加载</p>
</li>
<li><p>入口起点：</p>
</li>
</ol>
<ul>
<li>原来在src目录下创建index.js作为入口文件，webpack编译后生成index.bundle.js文件</li>
<li>现在创建index.js和another.js两个入口文件，webpack编译后生成index.bundle.js和another.bundle.js两个文件，</li>
<li>优点：做到了将大的文件拆分成相对小一点的文件，让浏览器并行加载</li>
</ul>
<p>入口起点有个缺点就是在编译后的文件里存在重复加载模块，解决办法就是将重复的模块放入公共的文件xx中，编译后会第一个xx.bundle.js。 </p>
<ol start="3">
<li>按需加载：</li>
</ol>
<ul>
<li>原来import导入的模块都被编译进了index.bundle.js文件里，导致编译后的文件过大，</li>
<li>通过import导入模块后.then里去使用该模块，编译的时候该模块只会进入xx.bundle.js中，xx.bundle.js和index.bundle.js共同被引入index.html中</li>
<li>import(‘/react’).then((react)=&gt;{正常使用})</li>
</ul>
<p>##二、转义速度过慢怎么办？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、</p>
<p>##三、写过webpack loader吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、没有写过，但是我知道大概的过程<br>2、</p>
<p>#算法部分：</p>
<p>##一、简述排序算法（冒泡排序、选择排序、计数排序、快速排序、插入排序、归并排序）</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、</p>
<p>##二、简述二分查找法？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、</p>
<p>#网络安全部分：</p>
<p>##一、什么是XSS攻击？如何预防？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>XSS是跨站脚本攻击，是一种安全漏洞，</li>
</ol>
<ul>
<li>攻击者在网站上注入恶意的客户端代码，</li>
<li>被攻击者登陆网站时就会自动运行这些恶意代码。</li>
</ul>
<ol start="2">
<li>预防方法有：</li>
</ol>
<ul>
<li>innerHTML改成innerText</li>
<li><p>把所有用户输入的内容中诸如“&lt; &gt; &amp;”等特殊的字符进行转义，不让它作为脚本代码正常运行，</p>
<p>  把 &lt; 替换成 ‘&amp;lt ;’<br>  把 &gt; 替换成 ‘&amp;gt ;’<br>  把 &amp; 替换成 ‘&amp;amp ;’<br>  把 ‘ 替换成 ‘&amp;apos’<br>  把 “ 替换成 ‘’</p>
</li>
<li>用户输入的恶意代码： 《script type=’text/javascript’&gt;alert(‘恶意代码’)<br>转换后：”&lt;scripttype=’text/javascript’&gt;alert(‘恶意代码’)&lt;/script&gt;”<br>好用函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeSafe</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">	<span class="keyword">if</span>(div.innerText)&#123;</span><br><span class="line">		div.innerText = str</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		div.textContent = str	<span class="comment">//支持火狐</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> div.innerHTML</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##二、什么是CSRF攻击？如何预防？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>CSRF是跨站请求伪造</li>
</ol>
<ul>
<li>用户首先登陆一个A网站，并得到cookie,</li>
<li>在没有退出A网站的情形下，访问黑客网站，</li>
<li>黑客网站会带着cookie信息自动访问A网站，执行恶意操作。</li>
</ul>
<ol start="2">
<li>预防方法有：</li>
</ol>
<ul>
<li>除了cookie验证外，还要验证请求报文中的Referer字段，如果不是自己网站的请求就拒绝执行。</li>
<li>验证cookie以外的信息，如添加手机短信验证或者token验证。</li>
<li>设置cookie的时候，设置HttpOnly，让JS不能读取到cookie</li>
</ul>
<p>#HTTP部分：</p>
<p>##一、Cookie是什么？Session是什么？二者之间有什么联系？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>一、cookie：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>cookie用来记录用户数据，cookie被保存在浏览器本地</li>
</ul>
<ol start="2">
<li>使用过程：</li>
</ol>
<ul>
<li>用户登录成功以后，</li>
<li>服务器通过Set-Cookie设置cookie，cookie值就是用户信息，</li>
<li>之后浏览器每次访问服务器，都会带上cookie，读取cookie就得到了用户的信息</li>
</ul>
<ol start="3">
<li>有效期：</li>
</ol>
<ul>
<li><p>cookie默认是关闭浏览器就消失，但是我们可以在服务器中通过Max-Age设置有效期或者通过Expires设置过期日期。</p>
</li>
<li><p>服务器通过cookie中保存的用户信息和数据库中保存的所有用户信息做个比对，就知道是哪个用户了。</p>
</li>
</ul>
<p>二、session：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>session用来记录用户数据，session本质是哈希表，里边是一个个键值对，键名就是随机数sessionId，键值就是用户的信息。</li>
</ul>
<ol start="2">
<li>使用过程：</li>
</ol>
<ul>
<li>用户通过浏览器登录服务器成功以后，</li>
<li>服务器通过Set-Cookie设置cookie，cookie值就是sessionId</li>
<li>之后浏览器每次访问服务器，都会带上cookie，读取cookie得到sessionId，然后在session哈希表中就得到了用户的信息。</li>
</ul>
<ol start="3">
<li>有效期：</li>
</ol>
<ul>
<li>session被存在服务器的内存中，服务器重新启动就会消失，所以我们重启服务器的时候都要备份一下session。</li>
</ul>
<p>三、cookie和session有什么联系？<br>session基于cookie实现的，<br>如果cookie不搭配session使用，那么cookie值就是用户的信息，该信息被明文暴露在了浏览器上，可以被更改也可以被容易的看到，很不安全，<br>如果搭配session使用，那么cookie值就是sessionId这个随机数，用户的信息是session哈希表中sessionId对应的值，该信息保存在服务器中，不会暴露给浏览器，所以安全。</p>
<p>##二、LocalStorage 是什么？SessionStorage是什么？二者之间有什么区别？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>一、LocalStorage：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>LocalStorage是本地存储，存储一些不用考虑安全性的信息，如是否提示过用户，像账号、密码等不能存在这里</li>
</ul>
<ol start="2">
<li><p>使用方法：</p>
<p> localStorage.setItem(‘名’, ‘值’)           //存值<br> localStorage.getItem(‘名’)                 //取值<br> localStorage.removeItem(‘名’)              //删值<br> localStorage.clear( )                     //清空</p>
</li>
<li><p>有效期：</p>
</li>
</ol>
<ul>
<li>永久有效，除非用户清理缓存</li>
</ul>
<ol start="4">
<li>补充：</li>
</ol>
<ul>
<li>只有相同域名的页面才能互相读取localStorage（没有同源那么严重）</li>
<li>localStorage跟HTTP无关，HTTP不会带上localStorage</li>
<li>每个域名最大存储量大概是10MB，浏览器不同数值不同</li>
</ul>
<p>二、SessionStorage：</p>
<ol>
<li>大体上和LocalStorage是一样的，只是有效期不一样，SessionStorage的有效期是页面关闭后失效，而LocalStorage永久有效，除非用户清理缓存</li>
</ol>
<p>##补充：indexDB是什么？</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>数据存储用的，cookie最大存4kb，localStorage和sessionStorage最大存10MB，都太小了</li>
<li>储存空间大：不少于250MB</li>
<li>哈希表结构，键值对存储</li>
<li>同源限制，网页只能访问自身域名下的数据库，而不能访问跨域的数据库</li>
</ul>
<p>##三、JSONP是什么？Ajax是什么？二者之间有什么区别？</p>
<p>一、JSONP：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>发送http请求</li>
</ul>
<ol start="2">
<li><p>使用方法：</p>
<p> let script = document.createElement(‘script’)<br> script.src = <code>/abc?callback${function(responseData){alert(responseData)}}</code><br> document.body.appendChild(script)</p>
</li>
</ol>
<blockquote>
<p>回答：  </p>
<ul>
<li>创建一个script标签并指定scr属性，src属性上加上回调函数  </li>
<li>将script标签添加到body中，同时，自动向后端发送请求  </li>
<li>接收到响应体，自动执行回调函数，回调函数的参数就是前端想要的数据</li>
</ul>
</blockquote>
<p>二、Ajax：</p>
<ol>
<li>作用：</li>
</ol>
<ul>
<li>发送http请求，实现了页面的局部刷新</li>
</ul>
<ol start="2">
<li>使用方法：</li>
</ol>
<ul>
<li>通过创建XMLHttpRequest对象，并调用onreadystatechange属性、open方法和send方法来发送请求。 </li>
</ul>
<p>三、两者之间有什么区别？</p>
<ul>
<li>都是前端向后端请求数据的技术，也都实现了局部刷新，也都对数据类型没有限制</li>
<li>JSON是动态创建<script>标签，AJAX是创建XMLHttpRquest对象</li>
<li>JSONP只能GET，AJAX能GET能POST</li>
<li>JSONP能跨域请求数据，AJAX不能，服务器端CORS(跨站资源共享)技术可以解决跨域问题</li>
</ul>
<p>##四、Cache-Control是什么？ETag是什么？两者之间有什么区别？</p>
<p>一、Cache-Control：</p>
<ul>
<li>Cache-Control是缓存控制，是服务器设置，它是为了提高web性能而存在的。</li>
<li>在有效期内发起请求，浏览器从本地读取资源，</li>
<li>在有效期外发起请求，浏览器从服务器得到资源，</li>
<li>如果想在有效期内从服务器下载资源，我们修改路径上的查询参数</li>
<li>有效期可以通过Max-Age设置成时间段，也可以通过Expires设置成截止日期</li>
</ul>
<p>二、ETag：</p>
<ul>
<li>Etag是资源的标识，由服务器设置，浏览器每次请求，服务器都会生成资源的新的Etag值，并且读取请求报文中的if-none-match中保存的上一次资源的Etag值，将两次的值作比较</li>
<li>比较结果相同，返回304，浏览器就从缓存中读取资源</li>
<li>比较结果不同，就把服务器端的资源放到响应体里交给浏览器</li>
<li>Etag值通常是资源的md5值</li>
</ul>
<p>三、有什么不同：</p>
<ul>
<li>Cache-Control在有效期内，不发送http请求，ETag总是会发送http请求。</li>
</ul>
<p>##五、LocalStorage和Cookie的区别是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>浏览器访问服务器，cookie会被自动带上，localStorage不会。   </li>
<li>cookie的有效期是会话期，localStorage的有效期是永远，<br>我们可以通过Expires和Max-Age来改变cookie有效期，<br>我们可以通过清除缓存来清除localStorage。</li>
<li>cookie可以存的信息量大概是4kb左右，localStorage大概是10MB左右。</li>
</ol>
<p>##六、HTTP状态码知道哪些？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ul>
<li>200：请求被服务器成功处理</li>
<li>301：永久重定向</li>
<li>302：临时重定向</li>
<li>304：文件没有修改，可以直接使用缓存的文件</li>
<li>404：请求的资源不存在，比如输入了错误的URL</li>
<li>503：服务器出错，现在不能完成浏览器的请求，一段时间之后可能会恢复</li>
</ul>
<p>##七、（必考）GET和POST的区别是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、数据位置：Get的数据放在URL的查询参数里，POST的数据放在请求体里；<br>2、大小限制：GET是1024个字符，POST大概是10MB以内；<br>3、安全性：GET没有POST安全，其实两者都不安全；<br>4、缓存：GET可以被缓存，可以被收藏进书签，POST可以被缓存，不能被收藏进书签<br>5、作用：GET用来读数据，POST用来写数据，POST不幂等<br>  （幂等的意思是不管发送多少次请求，结果都一样）</p>
<p>##八、（必考）怎么跨域？CORS是什么？postMessage 是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>方法一：利用JSONP实现跨域：</li>
<li><p>方法二：CORS实现跨域：</p>
<p> 在请求首部字段中加入Origin: <a href="http://www.xx.com:8080">http://www.xx.com:8080</a><br> 在响应首部字段中加入Access-Control-Allow-Origin: <a href="http://www.xx.com:8080">http://www.xx.com:8080</a></p>
</li>
<li><p>方法三：postMessage：</p>
</li>
</ol>
<p>##九、表单加密有什么方式？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1.</p>
<ul>
<li>浏览器对传输的数据转成md5值，并且和服务器商量好，在该md5值中混入一些其他数字</li>
<li>服务器得到数据，去掉混入的数据后得到真正的md5值，将md5值转化成数据即可</li>
</ul>
<p>#JavaScript部分：</p>
<p>##一、JS 有哪些数据类型？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、七大数据类型：number、string、Boolean、undefined、null、object、symble；</p>
<p>2、object包括数组、函数、正则和日期等等。</p>
<p>##二、Promise怎么使用等等</p>
<blockquote>
<p>答案：</p>
</blockquote>
<pre><code>function myPromise(){
    return new Promise((resolve, reject)=&gt;{
        setTimeout(()=&gt;{
            resolve() 或者 reject()
        }, 3000)
    })
}

myPromise().then(成功函数1，失败函数1).then(成功函数2，失败函数2)

补充1：resolve函数其实就是成功函数1，reject函数其实就是失败函数1
补充2：成功函数1执行成功时，调用成功函数2，失败时调用失败函数2
补充3：失败函数1执行成功时，调用成功函数2，失败时调用失败函数2
</code></pre><blockquote>
<p>回答：<br>1、首先声明一个函数fn，在函数里面return一个promise对象，promise对象这样去定义，new Promise并且传入一个函数，该函数接收resolve和reject两个参数，然后执行一个异步操作，操作成功就调用resolve，失败就调用reject<br>2、then接收两个函数参数，第一个函数参数就是resolve，第二个函数参数就是reject。</p>
</blockquote>
<p>##三、（必考） AJAX 手写一下？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<pre><code>let xhr = new XMLHttpRequest()
xhr.open(&apos;POST&apos;,&apos;/ajax&apos;)                                  
xhr.onreadystatechange = ()=&gt;{               
    if(xhr.readyState===4){
        if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 || xhr.status===304){
            console.log(&apos;请求成功&apos;)
            console.log(xhr.responseText)
        }else if(xhr.status&gt;=400){
            console.log(&apos;请求失败&apos;)
        }                                
    }
}
xhr.send(&apos;a=1&amp;b=2&apos;)
</code></pre><blockquote>
<p>回答：<br>1、我们发送一个ajax时有四个步骤：<br>2、第一个步骤是创建一个XMLHttpRequest实例，let xxx = new XMLHttpRequest()<br>3、第二个步骤是监听ajax的发送状态，我们先跳过<br>4、第三个步骤是调用xxx的open方法，建立ajax请求，参数1是请求方式，通常为get或post，参数2是请求路径，/xxxx<br>5、第四个步骤是调用xxx的send方法，发送ajax请求，参数是请求体</p>
</blockquote>
<p>6、现在返过来说一下步骤2，怎么去监听整个状态，我们写xxx.onreadystatechange等于一个函数，在函数体里首先判断ajax的发送状态是不是完成，即xxx.readyState是否是4，在这个范围内，我们在判断响应状态是否成功，即xhr.status&gt;=200 &amp;&amp; xhr.status<300 || xhr.status===304就是成功，xhr.status>=400就是失败。响应成功的时候，xxx.responseText就是响应数据。</p>
<p>##四、（必考）闭包是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、闭包的定义：如果一个函数使用了它范围之外的变量，那么这个函数和这个变量就组成了闭包。  </p>
<p>2、闭包的目的：让一个局部变量拥有全局变量的随处可以访问到的优点而又不拥有全局变量污染全局环境的缺点。</p>
<p>3、闭包的使用方法有三个步骤：<br>第一步：先定义一个变量date，值为100，再定义一个函数inner，函数内操作变量date<br>第二步：将变量date和函数inner封装在一个自调用函数里，让函数inner作为自调用函数的返回值<br>第三步：将自调用函数赋值给变量xx，此时xx就保存着函数inner的地址<br>第四步：每次写xx()的时候，都可以拿到date的值了</p>
<pre><code>let xx = (()=&gt;{
    let date = 100
    return ()=&gt;{return date++}
})()
</code></pre><p>##五、（必考）什么是立即执行函数？使用立即执行函数的目的是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、立即执行函数也叫作“自调用函数”，目的是造出一个局部作用域，防止污染全局变量。</p>
<p>2、它的写法有很多种，原则是声明完一个函数后立即调用它，为了防止和前面的代码产生关联，需要在function关键字开头加上！或者；作为分割。</p>
<pre><code>/*ES5 中的写法：*/
方式1：!function(){}()
方式2：;(function(){}())
方式3：;(function(){})()

/*ES6 中的写法：*/
{
    const name = &apos;zhangzhiguo&apos;
    let age = 18
}
</code></pre><p>##六、（必考）这段代码里的 this 是什么？</p>
<blockquote>
<p>答案:</p>
</blockquote>
<p>1、口诀：有call看call，没call看点，没call没点就是window，在严格模式下，不是window而是undefined，此口诀对箭头函数、类以及事件绑定不适用。</p>
<p>2、举例：</p>
<ul>
<li>fn.call(): this指的是call方法的第一个参数，apply和bind方法也一样；</li>
<li>obj.fn(): this指的是obj对象</li>
<li><p>fn(): this指的是window，如果是严格模式下，就是undefined</p>
</li>
<li><p>()=&gt;{}: 箭头函数内外this一样</p>
</li>
<li>let xx = new ClassName(): this指的是类的实例xx</li>
<li><p>btn.addEventListener(‘click’, function(){}): this指的是事件源btn</p>
</li>
<li><p>myPromise.then(function(){}): this就是window</p>
</li>
<li>myPromise.then(()=&gt;{}): this就是resolve被调用时的环境里的this</li>
</ul>
<blockquote>
<p>回答：</p>
</blockquote>
<ul>
<li>现在有一个函数fn，当我写fn()时，this指的是window，在严格模式下，this指的是undefined</li>
<li>现在有一个函数fn，当我写fn.call()时，this指的是call的第一个参数，这一条也适用于apply和    bind方法</li>
<li>现在有一个对象obj，它有一个方法fn，当我写obj.fn()时，this指的是obj对象</li>
<li>()=&gt;{}: 箭头函数内外this一样</li>
<li>let xx = new ClassName(): this指的是类的实例xx</li>
<li>btn.addEventListener(‘click’, function(){}): this指的是事件源btn</li>
</ul>
<p>##七、如何实现深拷贝？</p>
<blockquote>
<p>答案:</p>
</blockquote>
<p>1、方法一、利用JSON对象的stringfy和parse方法，<br>  缺点: 不支持函数、引用、undefined、RegExp、Date</p>
<pre><code>var a = {...}
var b = JSON.parse( JSON.stringify(a) )
</code></pre><p>2、方法二、递归方法</p>
<blockquote>
<p>回答：<br>方法一、JSON.parse括号，传入JSON.stringify括号，传入想要深拷贝的对象即可，</p>
</blockquote>
<p>##八、如何实现数组去重？</p>
<blockquote>
<p>答案:</p>
</blockquote>
<p>1、借助对象属性名</p>
<pre><code>let arr = [-2,&apos;2&apos;, 2 ,5,8,8,1,9,9,3,3]
function filterArray(arr){
    let obj = {}
    let newArr = []
    arr.map((item)=&gt;{
        if(obj[item] !== item){
            obj[item]=item
               newArr.push(item)
        }
    })
    return newArr
}
</code></pre><p>2、利用数组的indexof方法</p>
<pre><code>function filterArray(arr){
    let newArr = []
    arr.map((item)=&gt;{
        newArr.indexOf(item) === -1 &amp;&amp; newArr.push(item)
    })
    return newArr
}
</code></pre><blockquote>
<p>回答：</p>
</blockquote>
<ul>
<li>首先我定义一个新数组，然后遍历想要去重的数组，每次遍历的时候都做一个判断，看元素是否在新的数组里，在的话什么都不做，不在的话就把元素push到新数组里</li>
<li>当遍历完的时候，新数组就是去重后的数组了</li>
<li>我是怎么判断元素是否在新数组中的呢？我是调用新数组的indexOf方法并传入元素，如果结果为-1就表示元素不在新数组里，此时就把元素push到新数组里即可</li>
</ul>
<p>3、Set去重</p>
<pre><code>Array.from(new Set(arr))
</code></pre><p>##九、如何用正则实现 string.trim()？</p>
<blockquote>
<p>回答：</p>
</blockquote>
<pre><code>string.replace(/^\s+|\s+$/g, &apos;&apos;)
补充：^平方号是开头，\s是空格，+是多个，$是结尾，g匹配多个
</code></pre><p>##十、JS 原型是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、首先声明一个空数组a，此时空数组只有一个值为0的length属性<br>2、为什么可以调用a.push()方法呢？<br>3、原来a有一个隐藏的<em>proto</em>属性，指向a的构造函数Array的prototype属性，<br>4、Array.prototype就是我们所说的原型对象<br>5、通过Array构造函数构造出的实例对象，都从原型上继承属性和方法</p>
<p>构造函数的prototype属性指向一个对象，该对象内保存着所有通过构造函数创建的实例共享的属性和方法，该对象就是原型对象，简称原型，原型有个constructor属性，指向构造函数。</p>
<p>##十一、ES6中的class了解吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、类是ES6中的一个特殊函数，作用和ES5中的构造函数是一样的，它返回一个对象<br>2、我们这样去创建，class关键字后面接一个类名，然后花括号里写constructor函数，在该函数内部定义自有属性，在该函数外部定义公有属性，使用static关键字还可以定义静态属性<br>3、我们这样去使用，new关键字后面接类的名字并传入参数，它会自动调用constructor函数并返回一个对象，我们称该对象为类的实例<br>4、因为类的实例拥有类中的所有属性和方法，实现了代码复用的目的。</p>
<p>5、自有属性的值是根据实例的不同而不同的，所以写在constructor函数里，方便的使用constructor函数接收到的实例参数。<br>公有属性的值不会根据实例的不同而不同，所以写在constructor函数外面，不需要constructor函数接收到的实例参数。<br>静态属性是类声明内部用到的属性，而不会继承给实例对象。</p>
<p>##十二、JS 如何实现继承？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、ES5中实现继承，</p>
<pre><code>function Country(options){
    this.countryName = &apos;中国&apos;
}
Country.prototype.sayCountryName = function(){
    console.log(this.countryName)
}

function Capital(options){
    Contry.apply(this, options)
    this.capitalName = &apos;北京&apos;
}
Capital.prototype = Object.create(Country.prototype)
Capital.prototype.sayCapitalName = function(){
    console.log(this.capitalName)
}

let obj = new Capital()
obj.sayCapitalName()
obj.sayCountryName()
</code></pre><p>2、ES6中实现继承：</p>
<pre><code>class Country{
    constructor(){
        this.countryName = &apos;中国&apos;
    }
    sayCountryName(){
        console.log(this.countryName)
    }
}

class Capital extends Contry{
    constructor(props){
        super(props)
        this.capitalName = &apos;北京&apos;
    }
    sayCapitalName{
        console.log(this.capitalName)
    }
}

let obj = new Capital()
obj.sayCapitalName()
obj.sayCountryName()
</code></pre><blockquote>
<p>回答： </p>
</blockquote>
<p>1、ES5中是函数式继承，ES6中是类继承</p>
<p>2、函数式继承：假设函数A想要继承函数B，需要做两件事：<br>首先在函数A里用apply方法调用函数B，第一个参数是this，第二个参数函数A接收到的实参；<br>然后在函数A外面调用Object对象的create方法，并传入B.prototype作为参数值，将执行结果赋值给A.prototype。</p>
<p>3、类继承：假设类A想要继承类B，需要做两件事：<br>首先用class关键字声明类的时候，加上extends B，<br>然后在类A里constructor函数里调用super并传入constructor函数接收到的参数</p>
<p>##十五、== 相关题目直接反着答（放弃）</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>##十六、DOM 事件模型是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、原生JS有两种事件模型，一个是DOM0级事件模型，另一个是DOM2级事件模型，DOM0级有事件覆盖的问题，我们一般不用<br>2、DOM2级事件模型我准备从三方面阐述，<br>一是事件构成：事件源、事件类型、事件处理函数<br>二是添加和移除事件的方法：addEventListener()、removeEventListener()<br>三是事件流：事件流有两个阶段，分别是捕获阶段和冒泡阶段<br>    捕获阶段：从最不具体的元素到最具体的元素<br>    冒泡阶段：从最具体的元素到最不具体的元素<br>四是事件处理函数的执行顺序：先执行捕获阶段的，在执行冒泡阶段的，<br>    这里有个特例，就是绑定事件和触发事件的是同一个对象，那么捕获阶段和冒泡阶段谁写在前面谁就先执行。</p>
<p>##十七、事件委托是什么？有什么好处？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、事件委托是利用了事件冒泡解决了“事件处理程序过多”的问题，目的在于提高网站的性能。</p>
<p>2、比如我们想在一个ul的所有li子元素上添加click点击事件，我们只需要在ul元素上添加点击事件就可以了。</p>
<p>3、我们还可以监听暂时不存在的li元素，函数是这样的：</p>
<pre><code>function MyAddEventListener(element, eleType, selector, fn){
    element.addEventListener(eleType, (ev)=&gt;{
        let target = ev.target
        while(target !== element){
            if(target.tagName.toLowerCase() === selector){
                fn.call(null, ev)
                break
            }
            target = target.parentNode
        }
    })
}
</code></pre><blockquote>
<p>回答：<br>1、事件委托是利用了事件冒泡来解决“事件处理程序过多”的问题，目的在于提高网站的性能。<br>2、假设ul元素下边有3个li元素，如果想在li元素上添加click点击事件，我们只需要在ul元素上添加点击事件就可以了。<br>3、假设ul元素下边有3个li元素，每个li元素下边又有一个div元素，<br>我们先写一个循环，如果点击的元素不是ul元素，就进入循环体，<br>如果点击的元素是li元素，就执行事件处理函数，跳出循环体；<br>如果点击的元素不是li元素，就找到点击的元素的父元素，进入循环判断：是否是ul元素。</p>
</blockquote>
<p>##十八、移动端的触摸事件了解吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<ol>
<li>touchmove、touchstart、touchend</li>
<li>判断滑动方向：</li>
</ol>
<p>##十九、async/await 语法了解吗？目的是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、首先声明一个函数，在function关键字前面加上async关键字<br>2、然后在函数体内异步任务之前加上await关键字<br>3、浏览器执行的时候，会等异步任务结束后才执行后面的任务<br>4、这就达到了我们“先执行异步任务，拿到结果交给同步任务去操作的目的”<br>5、并且，代码整体上看，更像是在书写同步代码，从上往下依次执行，没有跳跃</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*async函数*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入fn函数'</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'时间到了'</span>)</span><br><span class="line">            resolve(<span class="string">'这里异步返回的结果'</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'fn函数的结果'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*async函数的调用*/</span></span><br><span class="line">fn().then(<span class="function">(<span class="params">xx</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xx)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn函数之后的同步函数'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果*/</span></span><br><span class="line">输出：进入fn函数</span><br><span class="line">输出：fn函数之后的同步函数</span><br><span class="line">输出：时间到了</span><br><span class="line">输出：这里异步返回的结果</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*async函数*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入fn函数'</span>)</span><br><span class="line">       setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'时间到了'</span>)</span><br><span class="line">       &#125;, <span class="number">2000</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'fn函数的结果'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*async函数的调用*/</span></span><br><span class="line">fn().then(<span class="function">(<span class="params">xx</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(xx)</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn函数之后的同步函数'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果*/</span></span><br><span class="line">输出：进入fn函数</span><br><span class="line">输出：fn函数之后的同步函数</span><br><span class="line">输出：fn函数的结果</span><br><span class="line">输出：时间到了</span><br></pre></td></tr></table></figure>
<p>##二十、构造函数？原型？原型链？</p>
<ol>
<li>构造函数：</li>
</ol>
<ul>
<li>构造函数是特殊的函数，它返回一个对象。</li>
<li>JS引擎会帮我们创建一个this对象，把所有属性和方法绑定到this上，最后将this返回</li>
<li>JS引擎还帮我们绑定原型对象，所有new出来的实例对象都从原型对象上继承属性和方法</li>
<li>我们通过new来调用构造函数</li>
</ul>
<ol start="2">
<li>原型：</li>
</ol>
<ul>
<li>构造函数的prototype属性指向一个对象，</li>
<li>该对象保存着所有构造函数创建出来的实例对象共享的属性和方法，</li>
<li><p>该对象就是原型对象，它有一个默认的constructor属性，指向构造函数。</p>
</li>
<li><p>构造函数的prototype属性指向原型，原型的constructor属性指向构造函数</p>
</li>
<li>实例对象的<em>proto</em>属性指向原型，实例对象的constructor属性指向构造函数</li>
</ul>
<ol start="3">
<li>原型链：</li>
</ol>
<ul>
<li>原型链的数据结构是树</li>
<li>属性查找时，先在对象上找，找到结束，找不到就去原型上找</li>
<li>原型上找到了就结束，找不到就去原型的原型上找</li>
<li>一直到Object.prototype对象为止，找到结束，找不到就返回undefined</li>
</ul>
<p>##二十一、包装对象</p>
<p>把数字基本类型值当成对象去操作时，JS引擎自动帮我们创建了一个包装对象，操作完毕JS引擎会自动帮我们销毁该包装对象，并且不影响原来的值。<br>包装对象三步走：创建对象、操作对象、销毁对象</p>
<p>#CSS部分：</p>
<p>##一、（必考）问题：说说盒模型？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、盒模型有两种，content-box和border-box，通过box-sizing属性设置。</p>
<p>2、content-box盒模型直观上理解就是“向外扩”，<br>假设现有有一个块级元素div，当我们设置了width后，在设置内边距时，盒子往外扩一点，在设置边框时，盒子又会往外扩一点，那么最终盒子的总尺寸就是width、padding、border三个值的总和，高度也是同样的道理。<br>假设现在有一个行内元素span，如果我们设置它的宽度和高度，是不起作用的，它的左右内边距、边框和外边距起作用，它的上下内边距、边框和外边距在空间上不起作用，在层叠上起作用。<br>假设现在有一个行内块元素div，它的显示效果和div是一样的。</p>
<p>3、border-box盒模型直观上理解就是“向里缩”，大致上和content-box一样，<br>假设现有有一个块级元素div，当我们设置了width后，在设置内边距时，盒子往里缩一点，在设置边框时，盒子又会往里缩一点，那么最终盒子的的总尺寸就是width值，高度也是同样的道理。  </p>
<p>##二、问题：css reset 和 normalize.css 有什么区别？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、我们写的HTML标签在浏览器中都有默认的样式，但是浏览器不同，默认样式也是不同的，这让我们很头疼，于是就出现了两种解决方案，一个是css reset样式重置，令一个是normalize.css样式正常化。</p>
<p>2、css rese是写一套样式将浏览器的默认样式全部替换掉，normalize.css是保留有价值的默认值，只修改会导致浏览器兼容问题的样式。</p>
<p>3、normalize.css是css reset的替代方案，功能更强大，他能同时修复桌面端和移动端浏览器的bug。</p>
<p>##三、问题：（必考）如何居中？</p>
<blockquote>
<p>逻辑： </p>
</blockquote>
<ul>
<li>水平：display、text-align、左右padding、绝对定位、margin为auto</li>
<li>垂直：display、line-height、上下padding、绝对定位、真table、假table</li>
</ul>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、这个问题分为水平居中和垂直居中，<br>想要水平居中时： </p>
<ul>
<li>最简单的方式就是在父元素上设置display为flex，justify-content为center即可。</li>
<li>当子元素是行内或行内块元素时，我们在父元素上设置text-align样式值为center即可。  </li>
<li>当子元素是块级元素且定宽时，我们在子元素上设置左右margin为auto即可。</li>
</ul>
<p>2、想要垂直居中时，有六种方法：</p>
<ul>
<li>最简单的方式就是在父元素上设置display为flex，alin-items为center即可。</li>
<li>如果父元素定高，我们还可以设父元素的上下padding值为父元素高度减去子元素的高度的一半即可。</li>
<li>当子元素是内联元素时，特指文字，我们在父元素上设置line-height，那么文字就会自动垂直居中</li>
<li>当子元素是块级元素时，可以让子元素绝对定位，然后设置top为50%，tranform的translate在垂直方向上负50%即可；</li>
</ul>
<p>##四、问题：选择器优先级如何确定？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、考虑权重：有!import &gt; 没有!import</p>
<p>2、考虑位置和引入方式：内联样式 &gt; 内部样式块 &gt; 外部样式表；后面出现 &gt; 前面出现</p>
<p>3、考虑特殊性：高特殊性 &gt; 低特殊性 &gt; 没有特殊性</p>
<p>特殊性数值为：<br>内联样式为1000；id选择器为0100；类选择器，伪类选择器，属性选择器为0010；通配符选择器为0000；特殊性为0000的通配符比没有特殊性的默认样式优先级高。</p>
<p>##五、问题：BFC是什么？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、BFC是格式化上下文，我准备从实际开发中遇到的4个bug来阐述这个问题<br>bug1：有两个div元素，是兄弟关系，都设置了外边距，此时外边距是两者之和吗？当然不是，因为发生了外边距合并。<br>bug2：有两个div元素，是父子关系，如果父元素没有设置border或者padding，子元素设置了上下margin，最终的显示效果是子元素margin超出父元素区域，使父元素移动。<br>bug3：ul中li元素全部浮动后，ul元素会出现塌陷，意思就是高度没有了。<br>bug4：如果一个元素浮动脱离了文档流，下面的元素就是跑上去，但是会被浮动的元素遮盖住。</p>
<p>2、这些问题都可以通过创建BFC解决，创建BFC的常见方式有五种：<br>overflow：hidden、display：flow-root或者inline-block、使元素浮动或绝对定位。</p>
<p>##六、问题：如何清除浮动？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、常见做法是：overflow: hidden，但是我不这么做<br>2、在父元素上增加一个伪类选择器，设置三个属性，</p>
<pre><code>.clearfix::after{content:&apos;&apos;; display: block; clear: both}
</code></pre><p>如果要兼容IE的话，.clearfix::after{content:’’; display: block; clear: both； zoom: 1}</p>
<p>##七、问题：CSS3动画了解吗？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、<br>    /<em>除两个时间外，顺序可以打乱</em>/<br>    transtion: &lt;参与属性&gt; &lt;持续时间&gt; &lt;动画节奏&gt; &lt;延迟时间&gt;        </p>
<pre><code>transform: translate(100px, 500px);    //平移
transform: scale(0.5, 2);        //缩放
transform: rotate(90deg);        //旋转
transform: skew(30deg, 60deg);        //扭曲
</code></pre><p>2、<br>    /<em>除两个时间外，顺序可以打乱</em>/<br>    animation: &lt;动画名称&gt; &lt;持续时间&gt; &lt;动画节奏&gt; &lt;延迟时间&gt; &lt;播放次数&gt; &lt;逆向播放&gt;</p>
<pre><code>@keyframes &lt;动画名称&gt;
{
    0% { opacity: 0 }
    100%{ opacity: 1 }
}
</code></pre><p>##一、问题：（必考） 你是如何理解 HTML 语义化的？</p>
<blockquote>
<p>文章：<a href="https://www.cnblogs.com/fliu/articles/5244866.html">https://www.cnblogs.com/fliu/articles/5244866.html</a></p>
</blockquote>
<blockquote>
<p>思路：什么是HTML语义化、原来做法及缺点、现在做法及优点、</p>
</blockquote>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、什么类型的内容就用什么标签去包裹，不能胡乱使用！</p>
<p>2、以前的做法是：内容使用无语义化的div和span标签，主要缺点有：</p>
<ul>
<li>代码不清晰，不利于开发者阅读</li>
<li>不利于SEO搜索引擎优化和爬虫抓取信息</li>
</ul>
<p>3、现在的做法是：表头用header、主体用main、表尾用footer、表头中导航条用nav、区块儿用section（区块儿的意思是页面中的分组或者文章中的段落）、侧边栏用aside、表尾联系方式用address、文章用article</p>
<p>##二、问题：meta viewport 是做什么用的，怎么写？</p>
<blockquote>
<p>思路：痛点、写法、解决痛点的方法</p>
</blockquote>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、meta:vp是防止手机网页自动缩放的，写法是：</p>
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

<p>2、为什么要写这句话呢？因为先有的大屏幕的电脑，后有小屏幕的手机，手机厂商为了让网页很好展示，就让网页整体缩小。但是会出现一个问题，就是内容太小了，想要看清楚，还要用两个手指去放大它，这当然不是我们想要的，于是我们加上meta:vp，不让它自动缩小。</p>
<p>##三、问题：canvas 元素是干什么的？</p>
<blockquote>
<p>答案：</p>
</blockquote>
<p>1、canvas是HTML5新增的元素，目的在于通过JavaScript中的脚本来绘制图形。</p>
<p>2、先在HTML文件中写入canvas标签，然后在JS文件中通过document.getElementById等方法将其转化成对象，然后调用该对象的getContext(‘2d’)方法，得到绘画上下文，然后根据创建的形状不同，调用不同的API即可。</p>
<p>3、注意点1：width和height属性应该写在canvas标签上而不是css样式里，因为width默认300px和height默认150px，样式中的width和height是根据这两个值做缩放而不是覆盖，这就导致画布中的元素也会缩放而出现失真。<br>注意点2：描边和填充的顺序问题，描边在前填充在后，尺寸是描边的尺寸；描边在后填充在前，尺寸是描边加填充的尺寸之和。</p>
</script></li></ul>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/25/resume/" data-id="cjoyiph9z000vj4qritneggxy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构和算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/数据结构和算法/" class="article-date">
  <time datetime="2018-11-23T03:30:20.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/数据结构和算法/">数据结构和算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：其他博客、<a href="http://bubkoo.com/tags/algorithm/" target="_blank" rel="noopener">排序算法可视化</a></p>
<p>#一、什么是数据结构？</p>
<ul>
<li>就是数据的结构。</li>
<li>一般来说是这样的：<ul>
<li>我们要解决一个跟数据相关的问题</li>
<li>分析这个问题，想出对应的数据结构</li>
<li>分析数据结构，想出算法</li>
<li>数据结构和算法是互相依存、不可分开的</li>
</ul>
</li>
<li>大分类<ul>
<li>分治法：把一个问题分区成互相独立的多个部分分别求解的思路。<br>  这种求解思路带来的好处之一是便于进行并行计算。</li>
<li>动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。</li>
<li>贪婪算法：常见的近似求解思路。<br>  当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。</li>
<li>线性规划法：见词条。</li>
<li>简并法：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而    求解    的方法。</li>
<li>前端主要使用分治法——分而治之。</li>
</ul>
</li>
</ul>
<p>#二、数据结构</p>
<p>###1. 哈希（hash）</p>
<ul>
<li>键值对形式</li>
<li>举例：对象、数组</li>
</ul>
<p>###2. 队列（queue）</p>
<ul>
<li>先进先出</li>
<li>可以用数组实现（push：放进去，放后面。shift：取出排头的元素）</li>
<li>举例：排队拿票</li>
</ul>
<p>###3. 栈（stack）</p>
<ul>
<li>先进后出</li>
<li>可以用数组实现（push：放进去，放后面。pop：弹出最后一个元素）</li>
<li>举例：向后转，齐步走</li>
</ul>
<p>###4. 链表（linked list）<br><img src="http://piks830x0.bkt.clouddn.com/%E9%93%BE%E8%A1%A8.JPG" alt=""></p>
<p>###5. 树（tree）</p>
<ul>
<li>举例：层级结构、DOM树</li>
</ul>
<p>#三、什么是算法？</p>
<ul>
<li>输入：<ul>
<li>一个算法必须有零个或以上输入量。</li>
</ul>
</li>
<li>输出：<ul>
<li>一个算法应有一个或以上输出量，输出量是算法计算的结果。</li>
</ul>
</li>
<li>明确性：<ul>
<li>算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，</li>
<li>通常要求实际运行结果是确定的。</li>
</ul>
</li>
<li>有限性：<ul>
<li>依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状    态、有限个输入符号和有限个转移函数（指令）。</li>
<li>一些定义更规定算法必须在有限个步骤内完成任务。</li>
</ul>
</li>
<li>有效性：<br>  又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</li>
</ul>
<p>#四、常见排序算法</p>
<p>###1. bubbleSort—-“冒泡排序”<br><a href="http://piks830x0.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" target="_blank" rel="noopener">冒泡排序：详细讲解</a></p>
<p>###2. insertionSort—-“插入排序”<br><a href="http://piks830x0.bkt.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" target="_blank" rel="noopener">插入排序：详细讲解</a></p>
<p>###3. selectionSort—-“选择排序”<br><a href="http://piks830x0.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" target="_blank" rel="noopener">选择排序：详细讲解</a></p>
<p>###5. bucketSort—-“桶排序”<br><a href="http://piks830x0.bkt.clouddn.com/%E6%A1%B6%E6%8E%92%E5%BA%8F.png" target="_blank" rel="noopener">桶排序：详细讲解</a></p>
<p>###4. quickSort—-“快速排序”<br><a href="http://piks830x0.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" target="_blank" rel="noopener">快速排序：详细讲解</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*快速排序*/</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> len = array.length</span><br><span class="line">       <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> array</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 确定中间元素位置，让中间元素作为基准元素</span></span><br><span class="line">       <span class="keyword">let</span> middleIndex = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>)</span><br><span class="line">       <span class="comment">// 原数组中删除中间的元素</span></span><br><span class="line">       <span class="keyword">let</span> middleValue = array.splice(middleIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">       <span class="comment">// 定义两个空数组</span></span><br><span class="line">       <span class="keyword">let</span> left = [], right = []</span><br><span class="line">       <span class="comment">// 循环遍历，此时数组少了基准元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">           array[i] &lt; middleValue ? left.push(array[i]) : right.push(array[i])</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> quickSort(left).concat([middleValue], quickSort(right)) </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>#五、排序算法的性能比较<br><img src="http://piks830x0.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/数据结构和算法/" data-id="cjoyiph9y000uj4qrxear0rjy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-Canvas" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/JS-Canvas/" class="article-date">
  <time datetime="2018-11-23T03:26:04.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/JS-Canvas/">JS-Canvas</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN文档</p>
<p>#一、canvas基本用法：</p>
<p>###1、准备工作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*html文件中，创建canvas元素*/</span></span><br><span class="line">&lt;canvas width=<span class="string">'300'</span> height=<span class="string">'150'</span> id=<span class="string">'canvas'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span>  <span class="comment">// 注意width和height</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*js文件中，将该元素转化成对象*/</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#canvas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用getContext()方法，得到绘图上下文*/</span></span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>)</span><br></pre></td></tr></table></figure></p>
<p>###2、矩形<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的矩形*/</span></span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.fillRect(x, y, width, height)</span><br><span class="line"><span class="comment">// x、y: 分别是起点X轴和y轴坐标</span></span><br><span class="line"><span class="comment">// width、heigth: 分别是矩形的宽度和高度</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的矩形*/</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeRect(x, y, width, height)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*清除矩形部分内容*/</span></span><br><span class="line">context.clearRect(x, y, width, height)</span><br></pre></td></tr></table></figure>
<p>###3、三角形<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的三角形*/</span></span><br><span class="line">context.beginPath()			<span class="comment">// 开始画画</span></span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.moveTo(x, y)		<span class="comment">// 起始点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.fill()				<span class="comment">// 填充</span></span><br><span class="line">context.closePath()			<span class="comment">// 结束画画</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的三角形*/</span></span><br><span class="line">context.beginPath()			<span class="comment">// 开始画画</span></span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.moveTo(x, y)		<span class="comment">// 起始点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 下一点</span></span><br><span class="line">context.lineTo(x, y)		<span class="comment">// 想要闭合，x和y是起始点；不想闭合，不用此lineTo()</span></span><br><span class="line">context.stroke()			<span class="comment">// 描边</span></span><br><span class="line">context.closePath()			<span class="comment">// 结束画画</span></span><br></pre></td></tr></table></figure>
<p>###4、圆形/圆弧<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制填充的圆形*/</span></span><br><span class="line">context.beginPath()</span><br><span class="line">context.fillStyle = <span class="string">'blue'</span></span><br><span class="line">context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">context.fill()</span><br><span class="line">context.closePath()</span><br><span class="line"><span class="comment">// x、y: 圆心x轴和y轴坐标</span></span><br><span class="line"><span class="comment">// radius: 半径</span></span><br><span class="line"><span class="comment">// startAngle、endAngle: 圆弧的起点和终点，Math.PI是π</span></span><br><span class="line"><span class="comment">// anticlockwise：true为顺时针、false为逆时针</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*绘制描边的圆形*/</span></span><br><span class="line">context.beginPath()</span><br><span class="line">context.lineWidth = <span class="number">10</span>		<span class="comment">// 线宽</span></span><br><span class="line">context.strokeStyle = <span class="string">'blue'</span></span><br><span class="line">context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">context.stroke()</span><br><span class="line">context.closePath()</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/JS-Canvas/" data-id="cjoyiph9k000bj4qrj8ule8l5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/网络安全/" class="article-date">
  <time datetime="2018-11-23T03:16:45.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/网络安全/">网络安全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：网上博客</p>
<p>#一、什么是XSS攻击？如何预防？</p>
<p>###1. 解释</p>
<ul>
<li>XSS是跨站脚本攻击，是一种安全漏洞，</li>
<li>攻击者在网站上注入恶意的客户端代码，</li>
<li>被攻击者登陆网站时就会自动运行这些恶意代码。</li>
</ul>
<p>###2. 预防方法：</p>
<ul>
<li>innerHTML改成innerText</li>
<li><p>把所有用户输入的内容中诸如“&lt; &gt; &amp;”等特殊的字符进行转义，不让它作为脚本代码正常运行，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">把 &lt; 替换成 <span class="string">'&amp;lt ;'</span></span><br><span class="line">把 &gt; 替换成 <span class="string">'&amp;gt ;'</span>  </span><br><span class="line">把 &amp; 替换成 <span class="string">'&amp;amp ;'</span></span><br><span class="line">把 <span class="string">' 替换成 '</span>&amp;apos<span class="string">'</span></span><br><span class="line"><span class="string">把 " 替换成 '</span><span class="string">'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用户输入的恶意代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用户输入*/</span></span><br><span class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;alert(<span class="string">'恶意代码'</span>)&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">/</span>*转换后*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">"&amp;lt;scripttype='text/</span>javascript<span class="string">'&amp;gt;alert('</span>恶意代码<span class="string">')&amp;lt;/script&amp;gt;"</span></span><br><span class="line"><span class="string">/*自定义的函数*/</span></span><br><span class="line"><span class="string">function changeSafe(str)&#123;</span></span><br><span class="line"><span class="string">  	let div = document.createElement('</span>div<span class="string">')</span></span><br><span class="line"><span class="string">  	if(div.innerText)&#123;</span></span><br><span class="line"><span class="string">  		div.innerText = str</span></span><br><span class="line"><span class="string">  	&#125;else&#123;</span></span><br><span class="line"><span class="string">  		div.textContent = str	//支持火狐</span></span><br><span class="line"><span class="string">  	&#125;</span></span><br><span class="line"><span class="string">  	return div.innerHtml</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>#二、什么是CSRF攻击？如何预防？</p>
<p>###1. 解释 </p>
<ul>
<li>CSRF是跨站请求伪造</li>
<li>用户首先登陆一个A网站，并得到cookie,</li>
<li>在没有退出A网站的情形下，访问黑客网站，</li>
<li>黑客网站会带着cookie信息自动访问A网站，执行恶意操作。</li>
</ul>
<p>###2. 预防方法有：</p>
<ul>
<li>除了cookie验证外，还要验证请求报文中的Referer字段，如果不是自己网站的请求就拒绝执行。</li>
<li>验证cookie以外的信息，如添加手机短信验证或者token验证。</li>
<li>设置cookie的时候，设置HttpOnly，让JS不能读取到cookie</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/网络安全/" data-id="cjoyiph9y000tj4qruht8uwm7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前后端交互" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/前后端交互/" class="article-date">
  <time datetime="2018-11-23T02:31:50.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/前后端交互/">前后端交互</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：《JS高程》page562页、《JS权威指南》page579页、方应杭视频</p>
<p>#九、Cookie是什么？Session是什么？二者之间有什么联系？</p>
<p>###1. cookie：</p>
<ul>
<li><ol>
<li>作用：<ul>
<li>cookie用来记录用户数据，cookie被保存在浏览器本地</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>使用过程：<ul>
<li>用户登录成功以后，</li>
<li>服务器通过Set-Cookie设置cookie，cookie值就是用户信息，</li>
<li>之后浏览器每次访问服务器，都会带上cookie，读取cookie就得到了用户的信息</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>有效期：<ul>
<li>cookie默认是关闭浏览器就消失，但是我们可以在服务器中通过Max-Age设置有效期或者通过Expires设置过期日期。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>###2. session：</p>
<ul>
<li><ol>
<li>作用：<ul>
<li>session用来记录用户数据，session本质是哈希表，里边是一个个键值对，键名就是随机数sessionId，键值就是用户的信息。</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>使用过程：<ul>
<li>用户通过浏览器登录服务器成功以后，</li>
<li>服务器通过Set-Cookie设置cookie，cookie值就是sessionId</li>
<li>之后浏览器每次访问服务器，都会带上cookie，读取cookie得到sessionId，然后在session哈希表中就得到了用户的信息。</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>有效期：<ul>
<li>session被存在服务器的内存中，服务器重新启动就会消失，所以我们重启服务器的时候都要备份一下session。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>###3. cookie和session有什么联系？</p>
<ul>
<li>session基于cookie实现的，</li>
<li>如果cookie不搭配session使用，那么cookie值就是用户的信息，<br>  该信息被明文暴露在了浏览器上，可以被更改也可以被容易的看到，很不安全，  </li>
<li>如果搭配session使用，那么cookie值就是sessionId这个随机数，<br>  用户信息是session哈希表中sessionId对应的值，该信息保存在服务器中，不会暴露给浏览器，所以安全。</li>
</ul>
<p>#八、LocalStorage 是什么？SessionStorage是什么？二者之间有什么区别？</p>
<p>###1. LocalStorage：</p>
<ul>
<li><ol>
<li>作用：<ul>
<li>LocalStorage是本地存储，存储一些不用考虑安全性的信息，如是否提示过用户，像账号、密码等不能存在这里</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>使用方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'名'</span>, <span class="string">'值'</span>)       	<span class="comment">//存值</span></span><br><span class="line">localStorage.getItem(<span class="string">'名'</span>)             	<span class="comment">//取值</span></span><br><span class="line">localStorage.removeItem(<span class="string">'名'</span>)          	<span class="comment">//删值</span></span><br><span class="line">localStorage.clear( )                 	<span class="comment">//清空</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li>有效期：<ul>
<li>永久有效，除非用户清理缓存</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>补充：<ul>
<li>只有相同域名的页面才能互相读取localStorage（没有同源那么严重）</li>
<li>localStorage跟HTTP无关，HTTP不会带上localStorage</li>
<li>每个域名最大存储量大概是10MB，浏览器不同数值不同</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>###2. SessionStorage：</p>
<ul>
<li>大体上和LocalStorage是一样的，只是有效期不一样，</li>
<li>SessionStorage的有效期是页面关闭后失效，而LocalStorage永久有效，除非用户清理缓存</li>
</ul>
<p>###3. indexDB是什么？</p>
<ul>
<li>数据存储用的，cookie最大存4kb，localStorage和sessionStorage最大存10MB，都太小了</li>
<li>储存空间大：不少于250MB</li>
<li>哈希表结构，键值对存储</li>
<li>同源限制，网页只能访问自身域名下的数据库，而不能访问跨域的数据库</li>
</ul>
<p>#七、Cache-Control是什么？ETag是什么？两者之间有什么区别？</p>
<p>###1. Cache-Control：</p>
<ul>
<li>Cache-Control是缓存控制，是服务器设置，它是为了提高web性能而存在的。</li>
<li>在有效期内发起请求，浏览器从本地读取资源，</li>
<li>在有效期外发起请求，浏览器从服务器得到资源，</li>
<li>如果想在有效期内从服务器下载资源，我们修改路径上的查询参数</li>
<li>有效期可以通过Max-Age设置成时间段，也可以通过Expires设置成截止日期</li>
</ul>
<p>###2. ETag：</p>
<ul>
<li>Etag是资源的标识，由服务器设置，浏览器每次请求，服务器都会生成资源的新的Etag值，并且读取    请求报文中的if-none-match中保存的上一次资源的Etag值，将两次的值作比较</li>
<li>比较结果相同，返回304，浏览器就从缓存中读取资源</li>
<li>比较结果不同，就把服务器端的资源放到响应体里交给浏览器</li>
<li>Etag值通常是资源的md5值</li>
</ul>
<p>###3. 有什么不同：</p>
<ul>
<li>Cache-Control在有效期内，不发送http请求，ETag总是会发送http请求。</li>
</ul>
<p>#六、表单加密有什么方式？<br>步骤1：浏览器对传输的数据转成md5值，并且和服务器商量好，在该md5值中混入一些其他数字<br>步骤2：服务器得到数据，去掉混入的数据后得到真正的md5值，将md5值转化成数据即可</p>
<p>#五、GET和POST的区别是什么？</p>
<ul>
<li>1、数据位置：Get的数据放在URL的查询参数里，POST的数据放在请求体里；  </li>
<li>2、大小限制：GET是1024个字符，POST大概是4~10MB左右；  </li>
<li>3、安全性：GET没有POST安全，其实两者都不安全；  </li>
<li>4、缓存：GET可以被缓存，可以被收藏进书签，POST可以被缓存，不能被收藏进书签</li>
<li>5、作用：GET用来读数据，POST用来写数据，POST不幂等<br>（幂等的意思是不管发送多少次请求，结果都一样）</li>
</ul>
<p>#四、同源策略：</p>
<ul>
<li>浏览器必须保证：只有协议+域名+端口号保持一模一样才允许发AJAX请求</li>
<li>判断：AJAX被定义时的IP地址与AJAX中open中定义的IP地址</li>
<li>情景：A服务器上的页面想要访问B服务器，<br>  需要在js文件中ajax的open中写入B服务器地址，<br>  需要在B服务器上设置下面的首都字段：<br>  `<pre><code>response.setHeader(&apos;Access-Control-Allow-Origin&apos;: &apos;http://192.168.0.103:8080&apos;)，  //后面的是A服务器地址
</code></pre>  `</li>
<li>form可以跨域，是因为form方法会刷新页面，导致原页面的脚本无法获取新页面中的内容，<br>  浏览器认为这是安全的。</li>
<li>如果不是百度页面里面的js，就不能向百度这个域名发起AJAX请求，<br>  但是JSONP方式可以，img、form、script、link等等。</li>
</ul>
<p>#三、怎么跨域？</p>
<p>###1. 利用JSONP实现跨域</p>
<p>###2. CORS实现跨域<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在请求首部字段中加入Origin: http:<span class="comment">//www.xx.com:8080</span></span><br><span class="line">   在响应首部字段中加入Access-Control-Allow-Origin: http:<span class="comment">//www.xx.com:8080</span></span><br></pre></td></tr></table></figure></p>
<p>###3. postMessage实现跨域</p>
<p>#二、AJAX和其他方式的比较：</p>
<ul>
<li>用form可以发get或post请求，但是会刷新页面或是新开页面</li>
<li>用a可以发get请求，但是会刷新页面或是新开页面</li>
<li>用img可以发get请求，但是只能以图片的形式展示</li>
<li>用link可以发get请求，但是只能以css的形式展示</li>
<li>用script可以发get请求，但是只能以脚本的形式运行</li>
<li>AJAX能以get、post、delete等等方法发送请求，想以什么形式展示就以什么形式展示</li>
</ul>
<p>#一、JSONP是什么？Ajax是什么？二者之间有什么区别？</p>
<p>###1. JSONP：</p>
<ul>
<li><ol>
<li>作用：<ul>
<li>发送http请求</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>什么是JSONP？<ul>
<li>JSONP是前端向后端请求数据的一种方式，</li>
<li>前端动态创建script和回调函数并发起get请求，</li>
<li>后端构造函数的执行并传入json格式的参数，</li>
<li>前端接收响应并执行回调函数，</li>
<li>至此便得到了想要的后端数据</li>
<li>备注：后端只是构造，并不调用，调用是在前端得到响应的一刹那！</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>使用方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">`/abc?callback<span class="subst">$&#123;<span class="keyword">function</span>(responseData)&#123;alert(responseData)&#125;</span>&#125;`</span> </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>###2. Ajax：</p>
<ul>
<li><ol>
<li>作用：<ul>
<li>发送http请求，实现了页面的局部刷新</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>使用方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'/ajax'</span>)                                  </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;               </span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>)&#123;........&#125;         </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(xhr.status&gt;=<span class="number">400</span>)&#123;......&#125;                                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>3.补充：</p>
</li>
<li>设置状态行<ul>
<li>不跨域：xhr.open(‘GET’, ‘/ajax’)                       </li>
<li>跨域：xhr.open(‘GET’, ‘<a href="http://zhang.com:8888/ajax&#39;" target="_blank" rel="noopener">http://zhang.com:8888/ajax&#39;</a>) </li>
</ul>
</li>
<li>设置首部字段 <ul>
<li>xhr.setRequestHeader(‘Content-Type’, ‘x-www-form-urlencoded’)</li>
</ul>
</li>
<li><p>设置请求主体 </p>
<ul>
<li>xhr.send(‘a=1&amp;b=2’)                                         </li>
<li>GET时浏览器认为不发送数据，故不显示</li>
</ul>
</li>
<li><p>获得状态行</p>
<ul>
<li>状态码：xhr.status        </li>
<li>解释信息：xhr.statusText                                                    </li>
<li>获得所有首部字段：xhr.getAllResponsHeaders()                  </li>
<li>获得单个首部字段：xhr.getResponseHeader(‘Content-Type’)                </li>
</ul>
</li>
<li>获得响应主体 <ul>
<li>xhr.responseText                                                     </li>
<li>数据转化                                         <ul>
<li>将符合JSON的字符串转化成相对应的JavaScript值<br><code>window.JSON.parse(xhr.responseText)</code></li>
</ul>
</li>
<li>返回响应第一部分时浏览器就知道了状态码，但是我们等响应主体全部被浏览器下载完后，readystate变为4以后再去判断statue，然后操作响应主体</li>
</ul>
</li>
</ul>
<p>###3. 两者之间有什么区别？</p>
<ul>
<li>都是前端向后端请求数据的技术，也都实现了局部刷新，也都对数据类型没有限制</li>
<li>JSON是动态创建<script>标签，AJAX是创建XMLHttpRquest对象</li>
<li>JSONP只能GET，AJAX能GET能POST</li>
<li>JSONP能跨域请求数据，AJAX不能，服务器端CORS(跨站资源共享)技术可以解决跨域问题</li>
</ul>
</script></li></ul>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/前后端交互/" data-id="cjoyiph9x000sj4qr1hv050y3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP-基础" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/HTTP-基础/" class="article-date">
  <time datetime="2018-11-23T01:53:31.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/HTTP-基础/">HTTP-基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：《图解HTTP》</p>
<p>#一、HTTP基础知识</p>
<ul>
<li>无状态协议<ul>
<li>HTTP是无状态协议，即请求和响应的信息它一点都不会保存</li>
</ul>
</li>
<li>持久连接：<ul>
<li>原来是收到请求马上响应，响应结束立即断开连接，三次握手和四次挥手浪费很多时间，</li>
<li>现在是只要任意一端没有提出断开连接，就一直保持TCP连接状态。</li>
<li>HTTP 1.1版本中添加的，自动添加进请求的首部字段中，默认Connection: Keep-Alive</li>
<li>服务器收到请求后看到该字段，就会自动在响应字段中添加：Connection: Keep-Alive</li>
</ul>
</li>
<li>管线化：<ul>
<li>建立连接后，同时发送多个请求，而不是一个接一个的等待响应</li>
</ul>
</li>
<li>缓存机制：<ul>
<li>《JS-前后端交互》章节中有详细介绍，此处不赘述</li>
</ul>
</li>
</ul>
<p>#二、从输入地址到页面加载，经历了什么？</p>
<ul>
<li>1、输入域名：</li>
<li>2、域名解析：</li>
<li>3、三次握手：</li>
<li>4、发送请求：</li>
<li>5、返回响应：</li>
<li>6、解析代码和渲染页面：</li>
<li>7、四次挥手：</li>
</ul>
<p>###1. 输入域名</p>
<ul>
<li>绝对URL：协议名+登录信息+服务器地址+服务器端口号+文件路径+查询字符串+片段标识符</li>
<li>相对URL：</li>
<li>补充：<ul>
<li>命令行中curl IP地址，也会出现网页，这是最最简单的client（浏览器），</li>
<li>curl -v IP地址可以得到请求的详细信息</li>
<li>url中不能有中文，特殊字符需转化，看图片</li>
</ul>
</li>
</ul>
<p>###2. 域名解析</p>
<ul>
<li>搜索浏览器自身的DNS缓存，找到IP地址就使用，没有就继续找；</li>
<li>搜索系统自身的DNS缓存，找到IP地址就使用，没有就继续找；</li>
<li>搜索硬盘中的host文件，找到IP地址就使用，没有就继续找；</li>
<li>向宽带运营商或域名服务器发起DNS解析请求，获得IP地址；</li>
</ul>
<p>###3. 三次握手</p>
<ul>
<li>浏览器向IP所在的服务器发起TCP连接</li>
<li>为什么三次呢？因为要确保浏览器和服务器都能收发信息</li>
</ul>
<p>###4. 发送请求</p>
<ul>
<li>发送请求（请求报文）：浏览器向IP指向的服务器发起HTTP请求</li>
<li>4种常用请求方法：<ul>
<li>GET（获取资源）</li>
<li>POST（发送资源）</li>
<li>PUT（上传资源）</li>
<li>DELETE（删除）</li>
</ul>
</li>
</ul>
<p>###5. 返回响应</p>
<ul>
<li>返回响应（响应报文）：服务器收到请求，根据路径参数返回相应的数据，首先是HTML文件</li>
</ul>
<p>###6. 解析代码和渲染页面<br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器工作原理资料</a></p>
<ul>
<li>呈现引擎从网络层获得响应主体（即HTML文档）</li>
<li>先解析HTML文档head标签，边解析边创建DOM树，<ul>
<li>遇到link引用style文件和script引用JS文件，就通过http请求和响应来获得它们；</li>
</ul>
</li>
<li>再解析HTML文档body标签，将DOM树和解析css文件获得的style规则相结合创建render树（呈现树）<pre><code>* 遇到诸如img标签时，也是通过http请求和响应来获得它们
</code></pre></li>
<li>布局呈现树</li>
<li>渲染呈现树</li>
</ul>
<p>###7. 四次挥手</p>
<ul>
<li>如果浏览器没有后续的请求，浏览器就会和服务器发起TCP断开</li>
</ul>
<p>#三、TCP/IP分层</p>
<p>###1. 应用层</p>
<ul>
<li>作用：HTTP协议生成请求报文</li>
<li>FTP—-“文件传输协议”</li>
<li>DNS—-“域名系统”</li>
<li>HTTP—-“超文本传输协议”</li>
</ul>
<p>###2. 传输层</p>
<ul>
<li>作用：报文分割，三次握手</li>
<li>TCP—-“传输控制协议”</li>
<li>UDP—-“用户数据报协议”</li>
</ul>
<p>###3. 网络层</p>
<ul>
<li>作用：确定传输路线，将数据包准确送达</li>
<li>IP—-“网际协议”</li>
</ul>
<p>###4. 链路层</p>
<ul>
<li>作用：处理连接网络的硬件部分。</li>
<li>内容：包括操作系统、设备驱动、网卡和光纤等</li>
</ul>
<p>#四、请求报文和响应报文简述：<br><img src="http://piks830x0.bkt.clouddn.com/%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.JPG" alt=""></p>
<p>#五、辅助理解</p>
<ul>
<li><p><img src="http://piks830x0.bkt.clouddn.com/http%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/http%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/HTTP-基础/" data-id="cjoyiph9h0009j4qrpkn9ijla" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-DOM模型" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/JS-DOM模型/" class="article-date">
  <time datetime="2018-11-23T01:13:58.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/JS-DOM模型/">JS-DOM模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：《JS高程》page286页、《JS权威指南》page361页</p>
<p>#一、DOM实战</p>
<p>##1.元素</p>
<p>####1. 增加：</p>
<ul>
<li>createElement() —-“创建一个给定标签的新元素”</li>
</ul>
<p>####2. 删除：</p>
<ul>
<li>removeChild() —-“从DOM树中删除该对象”</li>
</ul>
<p>####3. 查找：</p>
<ul>
<li>querySelector() —-“返回文档中与指定选择器匹配的节点列表中的第一个节点”</li>
<li>querySelectorAll() —-“返回文档中与指定选择器匹配的节点列表”</li>
<li>getElementById() —-“返回给定id名的那个元素”</li>
<li>getElementsByClassName() —-“返回具有给定类名的元素列表”</li>
<li>getElementByName() —-“返回具有给定名称的元素列表”</li>
<li><p>getElementByTagName() —-“返回具有给定标记名称的元素列表”</p>
</li>
<li><p>parentNode—-“父节点”</p>
<ul>
<li>parentNode属性返回当前节点的父节点，没有父节点就返回null；</li>
<li>父节点只有三种类型：element节点、document节点、documentfragment文档片段节点；</li>
<li>文档节点（document）和文档片段节点（documentfragment）的父节点都是null；</li>
<li>另外，对于那些生成后还没插入 DOM 树的节点，父节点也是null；</li>
</ul>
</li>
<li>parentElement—-“父元素节点”<ul>
<li>parentElement属性返回当前节点的父元素节点，没有父元素节点就返回null；</li>
<li>父元素节点只可能是一种类型：element元素节点；</li>
</ul>
</li>
<li>ParentNode.children—-“返回所有子元素为Element的对象”</li>
<li>ParentNode.firstElementChild—-“返回第一个为element的子节点”</li>
<li>ParentNode.lastElementChild—-“返回最后一个为element的子节点”</li>
<li>ParentNode.childElementCount—-“返回ParentNode元素的子元素数量”</li>
<li>nextSibling—-“弟弟节点”</li>
<li>previousSibling—-“哥哥节点”</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*所有兄弟元素*/</span></span><br><span class="line"><span class="keyword">let</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'xx'</span>)</span><br><span class="line"><span class="keyword">let</span> array = []</span><br><span class="line"><span class="keyword">let</span> children = ele.parentElement.children</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;children.length; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(children[i].nodetype === <span class="number">1</span> &amp;&amp; children[i] !== ele)&#123;</span><br><span class="line">    array.push(children[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###4. 插入DOM树：</p>
<ul>
<li>appendChild() —-“插入子节点”<ul>
<li>appendChild方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点</li>
<li>如果参数节点是DOM已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置</li>
<li>该方法的返回值就是插入文档的子节点</li>
</ul>
</li>
<li>insertBefore() —-“插入节点”<ul>
<li>insertBefore方法用于将某个节点插入父节点内部的指定位置；</li>
<li>insertBefore方法接受两个参数：<pre><code>* 第一个参数是所要插入的节点newNode，
* 第二个参数是父节点parentNode内部的一个子节点referenceNode，newNode将插在该子节点的前面。
</code></pre></li>
<li>返回值是插入的新节点newNode；</li>
<li>如果第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</li>
<li>如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</li>
<li>由于不存在insertAfter方法，如果新节点要插在父节点的某个子节点后面，可用insertBefore方法结合nextSibling属性模拟。</li>
</ul>
</li>
<li>replaceChild() —-“替换节点”<ul>
<li>replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。</li>
<li><code>var replacedNode = parentNode.replaceChild(newChild, oldChild);</code><pre><code>* 第一个参数newChild是用来替换的新节点，
* 第二个参数oldChild是将要替换走的子节点。
</code></pre></li>
<li>返回值是替换走的那个节点oldChild。</li>
</ul>
</li>
</ul>
<p>##2. 属性</p>
<p>####1. 增加：</p>
<ul>
<li>setAttribute() —-“增/改属性”</li>
</ul>
<p>####2. 删除：</p>
<ul>
<li>removeAttribute() —-“删除属性，删除指定的属性”</li>
</ul>
<p>####3. 查值：</p>
<ul>
<li>getAttribute() —-“查找属性，返回指定的属性值”</li>
<li>getAttributeNames()—-“返回所有属性名组成的数组”</li>
</ul>
<p>####4. 测有无：</p>
<ul>
<li>hasAttribute() —-“测属性有无”</li>
<li>hasAttributes() —-“测一个或多个属性有无”</li>
</ul>
<p>##3. 元素内容</p>
<p>####1. 增加、删除、改值、查值</p>
<ul>
<li>innerText—-“当前节点和其所有后代节点的文本内容”<ul>
<li>和textContent作用相同，MDN上有他两之间的差异讲解</li>
</ul>
</li>
<li>textContent—-“当前节点和其所有后代节点的文本内容”<ul>
<li>将每个子节点的内容连接在一起返回，但是不包括注释节点，</li>
<li>如果一个节点没有子节点，则返回空字符串</li>
<li>document节点和documentType节点，两者的textContent属性为null</li>
</ul>
</li>
<li>innerHTML—-“返回某个元素的后代元素的html内容”</li>
<li>outerHTML—-“返回某个元素及其后代元素的html内容”</li>
</ul>
<p>##4. 类的操作</p>
<ul>
<li>classList—-“返回class属性值组成的对象”</li>
<li>ele.classList.add(xxx)———-添加指定的类值</li>
<li>ele.classList.remove(xxx)—–删除指定的类值</li>
<li>ele.classList.toggle(xxx)——类值开关，有则删，无则加</li>
<li>ele.classList.contains(xxx)—-检查是否含有指定的类值</li>
<li>ele.classList.replace()——–新类整体替换旧类</li>
</ul>
<p>##5. 样式</p>
<p>####1. 增加</p>
<ul>
<li>ele.style.color = “red” —-“添加内联样式”</li>
<li>ele.style.cssText = “width: 50px; height:50px“ —-“添加内联样式”<br>####1. 查找</li>
<li>getComputedStyle(ele, null)—-“查询计算样式”</li>
</ul>
<p>#二、DOM基础知识</p>
<p>##1. DOM定义及节点的原型链</p>
<ul>
<li>DOM是Document Object Model，即文档对象模型，通俗的说就是将文档转化成对象的模型；</li>
<li>DOM的最小组成单位是节点node，每个节点都是包含着属性和方法的对象，这些节点按照所在的层级排    列成树形结构；</li>
<li>页面中的节点通过Element、Text、Document、Commet构造函数，构造出相应的对象，这就是DOM的主要功能。</li>
<li>接口提供了一种用以说明一个对象应该具有哪些方法的手段，尽管他可以表明这些方法的含义，但是却不包含具体实现。</li>
</ul>
<p>##2. Node接口</p>
<ul>
<li>一共有7种类型节点，这些节点都继承了原生的节点对象Node：<ul>
<li>1、Document: 整个文档树的顶层节点；</li>
<li>2、DocumentType: doctype标签，比如<code>&lt;!Doctype html&gt;</code></li>
<li>3、Element: 网页的各种HTML标签（比如<code>&lt;head&gt;、&lt;body&gt;、&lt;a&gt;、&lt;p&gt;</code>等） </li>
<li>4、Attribute: 网页元素的属性（比如<code>class=&quot;wrap&quot;</code>） </li>
<li>5、Text: 标签之间或标签包含的文本</li>
<li>6、Comment: 注释</li>
<li>7、DocumentFragment: 文档的片段</li>
</ul>
</li>
</ul>
<p>##3. NodeList接口</p>
<ul>
<li>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点；</li>
<li>DOM 提供两种节点集合，用于容纳多个节点：NodeList和HTMLCollection。</li>
<li>许多 DOM 属性和方法，返回的结果是NodeList实例或HTMLCollection实例。</li>
<li>NodeList实例是一个类/伪数组（对象），它的元素是节点（对象）。</li>
<li>注意，NodeList 实例可能是动态集合，也可能是静态集合，</li>
<li>目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。</li>
</ul>
<p>##4. HTMLCollection接口</p>
<ul>
<li>和NodeList接口相近，</li>
<li>HTMLCollection是一个元素节点的集合，只包含元素节点（element），不包含其他类型的节点。</li>
<li>它的返回值是一个类数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历。</li>
<li>返回HTMLCollection实例的，主要是一些Document对象的集合属性，如document.links、document.images等。</li>
<li>注意，children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。</li>
<li>如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。</li>
<li>另外，HTMLCollection是动态集合，会实时反映 DOM 的任何变化。</li>
</ul>
<p>##5. ParentNode接口</p>
<ul>
<li>节点对象除了继承 Node接口以外，还会继承其他接口。</li>
<li>ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。</li>
<li>ChildNode接口表示当前节点是一个子节点，提供一些相关方法。</li>
<li>如果当前节点是父节点，就会继承ParentNode接口。</li>
<li>由于只有元素节点element、文档节点document和文档片段节点documentFragment拥有子节点，<br>  因此只有这三类节点会继承ParentNode接口。</li>
</ul>
<p>##6.ChildNode接口</p>
<ul>
<li>如果一个节点有父节点，那么该节点就继承了ChildNode接口。 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/JS-DOM模型/" data-id="cjoyiph9m000dj4qr3f3w3vip" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-事件" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/JS-事件/" class="article-date">
  <time datetime="2018-11-23T00:19:07.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/JS-事件/">JS-事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：《JS高程》page345页、《JS权威指南》page440页</p>
<p>#一、基础概念：</p>
<p>###1. 事件定义：<br>文档或浏览器中发生的一些特定的交互瞬间</p>
<p>###2. 事件构成：</p>
<ul>
<li>事件源：指定事件发生在哪个元素上</li>
<li>事件类型：发生了哪种事件</li>
<li>事件处理程序：事件发生时执行的函数 </li>
</ul>
<p>###3. 事件流定义：</p>
<ol>
<li>定义：接收事件的顺序</li>
<li>事件流三阶段：<ul>
<li>捕获阶段：从最不具体的元素到最具体的元素 </li>
<li>处于目标阶段（冒泡阶段的一部分）</li>
<li>冒泡阶段：从最具体的元素到最不具体的元素</li>
</ul>
</li>
<li>捕获和冒泡谁先执行？</li>
</ol>
<ul>
<li>绑定事件的元素和触发事件的元素不同时，先执行捕获阶段的，后执行冒泡阶段的；</li>
<li>绑定事件的元素和触发事件的元素相同时，代码里面谁在前面谁就先执行。</li>
</ul>
<ol start="4">
<li>某个元素上发生某个事件时，都会在左侧从上到下询问一遍，紧接着在右侧从下到上询问一遍，<br>虽然左侧右侧都会询问一遍，但只会在设定的那一侧才执行：</li>
</ol>
<p>#二、事件处理函数：</p>
<p>###1. DOM2级事件处理程序（建议使用）</p>
<ul>
<li>增<ul>
<li>例：<code>btn.addEventListener(&quot;click&quot;, handler, false);</code></li>
</ul>
</li>
<li>删<ul>
<li>例：<code>btn.removeEventListener(&quot;click&quot;, handler, false);</code></li>
</ul>
</li>
<li>备注<ul>
<li>false规定只在冒泡阶段发生（包括目标阶段），默认是false，不写也是false</li>
</ul>
</li>
</ul>
<p>###2. DOM0级事件处理程序（不建议使用）</p>
<ul>
<li><p>增</p>
<ul>
<li>例：<code>btn.onclick=handler;</code></li>
</ul>
</li>
<li><p>删</p>
<ul>
<li>例：<code>btn.onclick=null;</code></li>
</ul>
</li>
<li>DOM0级会覆盖，比如后面添加的onclick会覆盖前面的onclick，不要使用；</li>
</ul>
<p>###3. HTML（勿用）事件处理程序</p>
<ul>
<li><p>增</p>
<ul>
<li>例：<code>&lt;input onclick=&quot;handler&quot;/&gt;</code></li>
</ul>
</li>
<li><p>删</p>
<ul>
<li>例：<code>input.onclick=null;</code></li>
</ul>
</li>
</ul>
<p>###4. IE（勿用）事件处理程序</p>
<ul>
<li>增<ul>
<li>例：<code>btn.attachEvent(&quot;onclick&quot;, handler);</code></li>
</ul>
</li>
<li>删<ul>
<li>例：<code>btn.detachEvent(&quot;onclick&quot;, handler);</code></li>
</ul>
</li>
</ul>
<p>#三、事件类型：</p>
<p>###1. UI事件</p>
<ul>
<li>load：内容完全加载后在相应对象上触发，<ul>
<li>当页面完全加载后在window对象上触发（完全：包括所有图像、JS和CSS等外部资源）</li>
<li>当图像完全加载后在img元素对应的对象上触发</li>
</ul>
</li>
<li>DOMContentLoaded：形成完整的DOM树之后就会触发，<ul>
<li>而不必等到所有外部资源都加载完毕后才会被触发</li>
</ul>
</li>
<li>unload：内容被完全卸载后在相应对象上触发</li>
<li>beforeunload：内容被卸载之前在相应对象上触发，<ul>
<li>在页面被卸载前起到给用户一个提示的作用</li>
</ul>
</li>
<li>resize：当浏览器窗口大小改变后在window对象上触发</li>
<li>scroll：当滚动条移动后在相应对象上触发</li>
<li>error：当发生JS错误时在相应对象上触发</li>
<li>select：当文本框（input或texterea）字符被选中时在对象上触发</li>
</ul>
<p>###2. 焦点事件<br><img src="http://piks830x0.bkt.clouddn.com/%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6.png" alt=""></p>
<p>补充：</p>
<ol>
<li>mouseover和mouseenter的区别：</li>
</ol>
<ul>
<li>mouseover：存在事件的冒泡传播机制，而mouseenter：浏览器把它的事件冒泡传播机制阻止了</li>
<li>鼠标从父元素进入到子元素：<ul>
<li>mouseover：先触发父元素的mouseout，再触发子元素的mouseover，因为冒泡，最后触发父元素的mouseover</li>
<li>mouseenter：先触发父元素的mouseleave，再触发子元素的mouseenter，因为不冒泡，所以父元素的mouseenter不被触发</li>
</ul>
</li>
</ul>
<p>###3. 键盘及文本事件<br>还有个input事件，用到过但还没深挖</p>
<p><img src="http://piks830x0.bkt.clouddn.com/%E9%94%AE%E7%9B%98%E5%8F%8A%E6%96%87%E6%9C%AC%E4%BA%8B%E4%BB%B6.png" alt=""></p>
<p><img src="http://piks830x0.bkt.clouddn.com/%E9%94%AE%E7%9B%98%E5%8F%8A%E6%96%87%E6%9C%AC%E4%BA%8B%E4%BB%B6%E4%B8%93%E6%9C%89%E5%B1%9E%E6%80%A7.png" alt=""></p>
<p>###4. 鼠标及滚轮事件<br><img src="http://piks830x0.bkt.clouddn.com/%E9%BC%A0%E6%A0%87%E5%8F%8A%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6.png" alt=""></p>
<p>补充：</p>
<ul>
<li>修改键：键盘上改变鼠标作用的按键<ul>
<li>shiftKey属性</li>
<li>ctrlKey属性</li>
<li>altKey属性</li>
<li>metaKey属性（windows键盘中是windows键，苹果电脑中是Cmd键）</li>
</ul>
</li>
<li>相关元素：relatedTarget属性，只对mouseover和mouseout才有属性值</li>
<li>单击次数累加值：detail属性，同一元素同一位置相继发生mousedown和mouseup后算一次单击。</li>
<li>元素距离页面顶部的距离：xxx.offsetTop </li>
<li>鼠标位置属性<ul>
<li>屏幕坐标：screenX、screenY</li>
<li>视口坐标：clientX、clientY</li>
<li>页面坐标：pageX、pageY</li>
<li>滚轮/页面距离：window.scrollX、window.scrollY</li>
</ul>
</li>
</ul>
<p>#三、事件委托</p>
<p>###1.定义： </p>
<ul>
<li>事件委托是利用了事件冒泡解决了“事件处理程序过多”的问题，目的在于提高网站的性能。</li>
<li>假设ul元素下边有3个li元素，如果想在li元素上添加click点击事件，我们只需要在ul元素上添加点击事件就可以了</li>
<li>我们还可以监听暂时不存在的li元素，页面结构: <code>ul&gt;li&gt;div</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyAddEventListener</span>(<span class="params">element, eleType, selector, fn</span>)</span>&#123;</span><br><span class="line">	element.addEventListener(eleType, (ev)=&gt;&#123;</span><br><span class="line">		<span class="keyword">let</span> target = ev.target</span><br><span class="line">		<span class="keyword">while</span>(target !== element)&#123;</span><br><span class="line">			<span class="keyword">if</span>(target.tagName.toLowerCase() === selector)&#123;</span><br><span class="line">               	fn.call(<span class="literal">null</span>, ev)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			target = target.parentNode</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>#四、移动端手指事件：</p>
<p>###1. 事件类型：</p>
<ul>
<li>touchstart、touchmove、touchend、gesture</li>
</ul>
<p>###2. 事件对象：</p>
<ul>
<li>changedTouches：记录手指在屏幕上的时候的信息；记录手指离开屏幕的一瞬间的信息</li>
<li>touches：只能记录手指在屏幕上的时候的信息</li>
</ul>
<p>###3. 用户动作类型：</p>
<ol>
<li>单手指操作: touchstart、touchmove、touchend模拟出来</li>
</ol>
<ul>
<li>点击：手指按下+手指离开（存在问题）</li>
<li>长按：手指按下+按住屏幕的时间超过750ms+手指离开</li>
<li>滑动：手指按下+滑动距离超过10px+手指离开</li>
</ul>
<ol start="2">
<li>多手指操作：gesture模拟出来</li>
</ol>
<ul>
<li>缩放</li>
<li>旋转</li>
</ul>
<p>###4. 判断用户单手指动作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="built_in">document</span>.querySelector(<span class="string">'#box'</span>)</span><br><span class="line"><span class="keyword">let</span> isMove = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> dir = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> start_x, start_y</span><br><span class="line"><span class="keyword">let</span> change_x, change_y</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 手指按下时触发 */</span></span><br><span class="line">box.addEventListener(<span class="string">'touchstart'</span>, (e)=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> point = e.changedTouches[<span class="number">0</span>]</span><br><span class="line">  start_x = point.pageX</span><br><span class="line">  start_y = point.pageY</span><br><span class="line">  isMove = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* 手指滑动时触发 */</span></span><br><span class="line">box.addEventListener(<span class="string">'touchmove'</span>, (e)=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> point = e.changedTouches[<span class="number">0</span>]</span><br><span class="line">  change_x = point.pageX - start_x</span><br><span class="line">  change_y = point.pageY - start_y</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(change_x)&gt;<span class="number">10</span> || <span class="built_in">Math</span>.abs(change_y)&gt;<span class="number">10</span>)&#123;</span><br><span class="line">    isMove = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* 手指松开时触发 */</span></span><br><span class="line">box.addEventListener(<span class="string">'touchend'</span>, (e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isMove)&#123;</span><br><span class="line">    	<span class="comment">// 代表：点击操作</span></span><br><span class="line">  		<span class="keyword">return</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   		<span class="keyword">if</span>(<span class="built_in">Math</span>.abs(change_x) &gt; <span class="built_in">Math</span>.abs(change_y))&#123;</span><br><span class="line">      		<span class="comment">// 代表：水平滑动</span></span><br><span class="line">       		dir = change_x &gt; <span class="number">0</span> ? <span class="string">'右滑'</span> : <span class="string">'左滑'</span></span><br><span class="line">      	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      		<span class="comment">// 代表：垂直滑动</span></span><br><span class="line">       		dir = change_y &gt; <span class="number">0</span> ? <span class="string">'下滑'</span> : <span class="string">'上滑'</span></span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="built_in">console</span>.log(dir)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>###5.已有的库：</p>
<ol>
<li>fastclick.js：<br>目的就是为了解决移动端click事件300ms延迟的问题</li>
<li>百度云touch手势事件库</li>
<li>hammer.js</li>
<li>zepto.js：提供移动端事件操作的板块，目前市场上使用率最高的（小型JQ）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).tap(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);				<span class="comment">// 点击</span></span><br><span class="line">$(<span class="string">'#box'</span>).singleTap(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);		<span class="comment">// 单击</span></span><br><span class="line">$(<span class="string">'#box'</span>).doubleTap(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);		<span class="comment">// 双击</span></span><br><span class="line">$(<span class="string">'#box'</span>).longTap(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);			<span class="comment">// 长按</span></span><br><span class="line">$(<span class="string">'#box'</span>).swipe(<span class="function"><span class="params">()</span>=&gt;</span>&#123; 				<span class="comment">// 滑动 </span></span><br><span class="line">	.swipeLeft/.swipeRight/.swipeUp/.swipeDown</span><br><span class="line">&#125;); </span><br><span class="line">$(<span class="string">'#box'</span>).pinchIn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) 	<span class="comment">// 缩小  </span></span><br><span class="line">$(<span class="string">'#box'</span>).pinchOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) 	<span class="comment">// 放大</span></span><br></pre></td></tr></table></figure>
<p>#五、其他</p>
<ol>
<li><p>取消事件的默认行为：<code>ev.preventDefault</code></p>
</li>
<li><p>阻止事件的传播：<code>ev.stopPropagation()</code></p>
</li>
</ol>
<p>#六、辅助理解：</p>
<ul>
<li><p><img src="http://piks830x0.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.png" alt=""></p>
</li>
<li><p><img src="http://piks830x0.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%9B%BE.png" alt=""></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/JS-事件/" data-id="cjoyiph9p000hj4qraxu4yytk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-相等和全等的区别" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-相等和全等的区别/" class="article-date">
  <time datetime="2018-11-22T14:32:29.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-相等和全等的区别/">JS-相等和全等的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：《JS高级程序设计》</p>
<p>#一、== 和 === 间的区别是什么？</p>
<p>###1、简述 </p>
<ul>
<li>==： 相等运算符，类型相同直接比较，类型不同先转换后比较</li>
<li>===：全等运算符，类型相同直接比较，类型不同直接false</li>
</ul>
<p>###2、相等运算符的转换规则：</p>
<p>#####（1）基本类型相互间比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*null和undefined不做类型转换，但null和undefined相等；*/</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="number">1</span>				<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="string">'1'</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="literal">true</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span>/<span class="literal">undefined</span> == <span class="literal">false</span>			<span class="comment">// 错误</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>				<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数字和字符串，字符串被Number()函数转成了数字*/</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'1'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'01'</span>			<span class="comment">// 正确		1 == 01</span></span><br><span class="line"><span class="comment">/*数字和布尔值，布尔值被Number()函数转成了数字*/</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'false'</span>		<span class="comment">// 正确		0 == 0</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'true'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串和布尔值，字符串和布尔值都被Number()函数转成了数字*/</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'1'</span>			<span class="comment">// 正确		1 == 1</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'0'</span>		<span class="comment">// 正确		0 == 0</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'123'</span>		<span class="comment">// 错误		1 == 123</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'123'</span>		<span class="comment">// 错误		0 == 123</span></span><br></pre></td></tr></table></figure>
<p>#####（2）引用类型间相互比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*比较的是地址，地址相同的情况*/</span></span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">age</span>: <span class="number">28</span>&#125;	<span class="comment">//假 地址：100</span></span><br><span class="line"><span class="keyword">let</span> d = c			<span class="comment">//假 地址：100</span></span><br><span class="line">c == d				<span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*比较的是地址，地址不同的情况*/</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;	<span class="comment">//假 地址：101</span></span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;	<span class="comment">//假 地址：102</span></span><br><span class="line">a == b				<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>#####（3）基本类型和引用类型比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对象和数字：对象转成数字*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="number">0</span>			<span class="comment">// 正确		0 == 0</span></span><br><span class="line">[<span class="number">123</span>] == <span class="number">123</span>		<span class="comment">// 正确		123 == 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象和字符串：对象转成字符串*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="string">'0'</span>			<span class="comment">// 正确		'0' == '0'</span></span><br><span class="line">[<span class="number">123</span>] == <span class="string">'123'</span>		<span class="comment">// 正确		'123' == '123'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象和布尔值，对象和布尔值都转成了数字*/</span></span><br><span class="line">[<span class="number">0</span>] == <span class="literal">true</span>		<span class="comment">// 错误		0 == 1</span></span><br><span class="line">[<span class="number">0</span>] == <span class="literal">false</span>	<span class="comment">// 正确		0 == 0</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">true</span>		<span class="comment">// 正确		1 == 1</span></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">false</span>	<span class="comment">// 错误		1 == 1</span></span><br><span class="line">[<span class="number">123</span>] == <span class="literal">true</span>	<span class="comment">// 错误		123 == 1</span></span><br></pre></td></tr></table></figure>
<p>#二、考题</p>
<ol>
<li>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 可能为 true 吗？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*a会自动调用toString()方法，该方法被我重写了*/</span></span><br><span class="line">a = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  toString()&#123;</span><br><span class="line">    a.value += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a.value </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-相等和全等的区别/" data-id="cjoyiph9w000qj4qr7m1o6pv4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-数据类型及类型转换" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/JS-数据类型及类型转换/" class="article-date">
  <time datetime="2018-11-22T14:12:09.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/JS-数据类型及类型转换/">JS-数据类型及类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#参考资料：MDN文档、《JS高程》、《JS权威指南》page32页</p>
<p>#一、JS中七大数据类型：</p>
<ul>
<li>数字—-Number</li>
<li>字符串—-String</li>
<li>布尔值—-Boolean</li>
<li>符号—-Symble</li>
<li>空—-Null</li>
<li>未定义—-Undefined</li>
<li>对象—-Object（包括对象、函数、数组）</li>
</ul>
<p>#二、类型判断：</p>
<p>###1. typeof 操作符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> →→→ <span class="built_in">Number</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> →→→ <span class="built_in">Number</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"ab"</span> →→→ <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"123"</span> →→→ <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>/<span class="literal">false</span> →→→ <span class="built_in">Boolean</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> →→→ <span class="built_in">Object</span>;      <span class="comment">//空的对象引用</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> →→→ Undefined;</span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; →→→ <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">typeof</span> [] →→→ <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">typeof</span> fun()&#123;&#125; →→→ <span class="built_in">Function</span>;</span><br></pre></td></tr></table></figure></p>
<p>###2. instanceof运算符</p>
<p>#三、类型转换</p>
<p>###1. 转成数字：</p>
<ol>
<li><p>Number(xxx)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*字符串*/</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'555'</span>);   <span class="comment">//555</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'abc'</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*布尔*/</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>);   <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>);   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空*/</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>);   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*未定义*/</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象*/</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>([]);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">a</span>:<span class="number">555</span>&#125;);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">555</span>]);   <span class="comment">//555</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">55</span>,<span class="number">22</span>]);   <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>xxx-0  常用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*字符串*/</span></span><br><span class="line"><span class="string">''</span> <span class="number">-0</span>;   <span class="comment">//0</span></span><br><span class="line"><span class="string">'555'</span> <span class="number">-0</span>;   <span class="comment">//555</span></span><br><span class="line"><span class="string">'abc'</span><span class="number">-0</span>;   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*布尔*/</span></span><br><span class="line"><span class="literal">true</span><span class="number">-0</span>;   <span class="comment">//1</span></span><br><span class="line"><span class="literal">false</span><span class="number">-0</span>;   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空*/</span></span><br><span class="line"><span class="literal">null</span><span class="number">-0</span>;   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*未定义*/</span></span><br><span class="line"><span class="literal">undefined</span><span class="number">-0</span>;   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象*/</span></span><br><span class="line">&#123;&#125;<span class="number">-0</span>;   <span class="comment">//NaN</span></span><br><span class="line">&#123;<span class="attr">a</span>:<span class="number">555</span>&#125;<span class="number">-0</span>;   <span class="comment">//NaN</span></span><br><span class="line">[]<span class="number">-0</span>;   <span class="comment">//0</span></span><br><span class="line">[<span class="number">555</span>]<span class="number">-0</span>;   <span class="comment">//555</span></span><br><span class="line">[<span class="number">55</span>,<span class="number">22</span>]<span class="number">-0</span>;   <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>+xxx</p>
</li>
<li><p>parseInt(xxx)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*字符串*/</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'555'</span>);   <span class="comment">//555</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*布尔*/</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">true</span>);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">false</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空*/</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">null</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*未定义*/</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">undefined</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象*/</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123;&#125;);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([]);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123;<span class="attr">a</span>:<span class="number">555</span>&#125;);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="number">555</span>]);   <span class="comment">//555</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="number">11</span>,<span class="number">22</span>]);   <span class="comment">//11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>parseFloat(xxx)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*字符串*/</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'555'</span>);   <span class="comment">//555</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'abc'</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*布尔*/</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">false</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空*/</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*未定义*/</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">undefined</span>);   <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象*/</span></span><br><span class="line"><span class="built_in">parseFloat</span>(&#123;&#125;);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>([]);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(&#123;<span class="attr">a</span>:<span class="number">555</span>&#125;);   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>([<span class="number">555</span>]);   <span class="comment">//555</span></span><br><span class="line"><span class="built_in">parseFloat</span>([<span class="number">11</span>,<span class="number">22</span>]);   <span class="comment">//11</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>###2. 转成字符串：</p>
<ol>
<li><p>String(xxx)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数字*/</span></span><br><span class="line"><span class="keyword">var</span> n=<span class="number">2</span>; </span><br><span class="line"><span class="built_in">String</span>(n)  <span class="comment">//'2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*布尔*/</span></span><br><span class="line"><span class="keyword">var</span> n=<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line"><span class="built_in">String</span>(n)  <span class="comment">//'true/false'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空和未定义*/</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>)  <span class="comment">//'null'</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>)  <span class="comment">//'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象*/</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; &#125;</span><br><span class="line">obj.toString( )  <span class="comment">//'[object object]'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>xxx+’’  常用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数字*/</span></span><br><span class="line"><span class="keyword">var</span> n=<span class="number">2</span>; </span><br><span class="line">n+<span class="string">''</span>  <span class="comment">//'2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*布尔*/</span></span><br><span class="line"><span class="keyword">var</span> n=<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">n+<span class="string">''</span>  <span class="comment">//'true/false'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空和未定义*/</span></span><br><span class="line"><span class="literal">null</span>+<span class="string">''</span>  <span class="comment">//'null'</span></span><br><span class="line"><span class="literal">undefined</span>+<span class="string">''</span>  <span class="comment">//'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象*/</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; &#125;</span><br><span class="line">obj1+<span class="string">''</span>  <span class="comment">//'[object object]' </span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">a</span>:<span class="number">123</span>, <span class="attr">b</span>:<span class="string">'fff'</span>&#125;</span><br><span class="line">obj2+<span class="string">''</span>   <span class="comment">//'[object object]'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [ ]</span><br><span class="line">arr1+<span class="string">''</span>   <span class="comment">//' '</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">45</span>]</span><br><span class="line">arr2+<span class="string">''</span>   <span class="comment">//'12,23,45'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>xxx.toString()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数字*/</span></span><br><span class="line"><span class="keyword">var</span> n=<span class="number">2</span>; </span><br><span class="line">n.toString( )  <span class="comment">//'2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*布尔*/</span></span><br><span class="line"><span class="keyword">var</span> n=<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">n.toString( )  <span class="comment">//'true/false'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空和未定义*/</span></span><br><span class="line"><span class="literal">null</span>.toString( )  <span class="comment">//报错</span></span><br><span class="line"><span class="literal">undefined</span>.toString( )  <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对象*/</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; &#125;</span><br><span class="line">obj.toString( )  <span class="comment">//'[object object]'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>###3. 转成布尔值：</p>
<ol>
<li><p>Boolean(xxx)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*只有下面5种情况是false，其他都是true，包括空对象*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数字*/</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>);   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串*/</span></span><br><span class="line"><span class="built_in">Boolean</span>(‘’)   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空和未定义*/</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>);   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>!!xxx  推荐</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*只有下面5种情况是false，其他都是true，包括空对象*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数字*/</span></span><br><span class="line">!! <span class="number">0</span>;   <span class="comment">//false</span></span><br><span class="line">!! <span class="literal">NaN</span>;   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串*/</span></span><br><span class="line">!! <span class="string">''</span>   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*空和未定义*/</span></span><br><span class="line">!! <span class="literal">null</span>;   <span class="comment">//false</span></span><br><span class="line">!! <span class="literal">undefined</span>;   <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/JS-数据类型及类型转换/" data-id="cjoyiph9t000mj4qr8qe2yaav" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/25/resume/">resume</a>
          </li>
        
          <li>
            <a href="/2018/11/23/数据结构和算法/">数据结构和算法</a>
          </li>
        
          <li>
            <a href="/2018/11/23/JS-Canvas/">JS-Canvas</a>
          </li>
        
          <li>
            <a href="/2018/11/23/网络安全/">网络安全</a>
          </li>
        
          <li>
            <a href="/2018/11/23/前后端交互/">前后端交互</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 张治国<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>